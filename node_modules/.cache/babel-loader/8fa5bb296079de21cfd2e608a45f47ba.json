{"ast":null,"code":"import schema from '@uniswap/token-lists/src/tokenlist.schema.json';\nimport Ajv from 'ajv';\n/**\n * Given a URI that may be ipfs, ipns, http, or https protocol, return the fetch-able http(s) URLs for the same content\n * @param uri to convert to fetch-able http url\n */\n\nfunction uriToHttp(uri) {\n  var _uri$match, _uri$match2;\n\n  const protocol = uri.split(':')[0].toLowerCase();\n\n  switch (protocol) {\n    case 'https':\n      return [uri];\n\n    case 'http':\n      return ['https' + uri.substr(4), uri];\n\n    case 'ipfs':\n      const hash = (_uri$match = uri.match(/^ipfs:(\\/\\/)?(.*)$/i)) === null || _uri$match === void 0 ? void 0 : _uri$match[2];\n      return [`https://cloudflare-ipfs.com/ipfs/${hash}/`, `https://ipfs.io/ipfs/${hash}/`];\n\n    case 'ipns':\n      const name = (_uri$match2 = uri.match(/^ipns:(\\/\\/)?(.*)$/i)) === null || _uri$match2 === void 0 ? void 0 : _uri$match2[2];\n      return [`https://cloudflare-ipfs.com/ipns/${name}/`, `https://ipfs.io/ipns/${name}/`];\n\n    default:\n      return [];\n  }\n}\n\nconst tokenListValidator = new Ajv({\n  allErrors: true\n}).compile(schema);\n/**\n * Contains the logic for resolving a list URL to a validated token list\n * @param listUrl list url\n */\n\nexport default async function getTokenList(listUrl) {\n  const urls = uriToHttp(listUrl);\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i];\n    const isLast = i === urls.length - 1;\n    let response;\n\n    try {\n      response = await fetch(url);\n    } catch (error) {\n      console.debug('Failed to fetch list', listUrl, error);\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`);\n      continue;\n    }\n\n    if (!response.ok) {\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`);\n      continue;\n    }\n\n    const json = await response.json();\n\n    if (!tokenListValidator(json)) {\n      var _tokenListValidator$e, _tokenListValidator$e2;\n\n      const validationErrors = (_tokenListValidator$e = (_tokenListValidator$e2 = tokenListValidator.errors) === null || _tokenListValidator$e2 === void 0 ? void 0 : _tokenListValidator$e2.reduce((memo, error) => {\n        var _error$message;\n\n        const add = `${error.dataPath} ${(_error$message = error.message) !== null && _error$message !== void 0 ? _error$message : ''}`;\n        return memo.length > 0 ? `${memo}; ${add}` : `${add}`;\n      }, '')) !== null && _tokenListValidator$e !== void 0 ? _tokenListValidator$e : 'unknown error';\n      throw new Error(`Token list failed validation: ${validationErrors}`);\n    }\n\n    return json;\n  }\n\n  throw new Error('Unrecognized list URL protocol.');\n}","map":{"version":3,"sources":["/Users/macbook/Desktop/juiceswap/juiceswap-docs/src/utils/tokenLists.ts"],"names":["schema","Ajv","uriToHttp","uri","protocol","split","toLowerCase","substr","hash","match","name","tokenListValidator","allErrors","compile","getTokenList","listUrl","urls","i","length","url","isLast","response","fetch","error","console","debug","Error","ok","json","validationErrors","errors","reduce","memo","add","dataPath","message"],"mappings":"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","sourcesContent":["import { TokenList } from '@uniswap/token-lists'\nimport schema from '@uniswap/token-lists/src/tokenlist.schema.json'\nimport Ajv from 'ajv'\n\n/**\n * Given a URI that may be ipfs, ipns, http, or https protocol, return the fetch-able http(s) URLs for the same content\n * @param uri to convert to fetch-able http url\n */\nfunction uriToHttp(uri: string): string[] {\n  const protocol = uri.split(':')[0].toLowerCase()\n  switch (protocol) {\n    case 'https':\n      return [uri]\n    case 'http':\n      return ['https' + uri.substr(4), uri]\n    case 'ipfs':\n      const hash = uri.match(/^ipfs:(\\/\\/)?(.*)$/i)?.[2]\n      return [`https://cloudflare-ipfs.com/ipfs/${hash}/`, `https://ipfs.io/ipfs/${hash}/`]\n    case 'ipns':\n      const name = uri.match(/^ipns:(\\/\\/)?(.*)$/i)?.[2]\n      return [`https://cloudflare-ipfs.com/ipns/${name}/`, `https://ipfs.io/ipns/${name}/`]\n    default:\n      return []\n  }\n}\n\nconst tokenListValidator = new Ajv({ allErrors: true }).compile(schema)\n\n/**\n * Contains the logic for resolving a list URL to a validated token list\n * @param listUrl list url\n */\nexport default async function getTokenList(listUrl: string): Promise<TokenList> {\n  const urls = uriToHttp(listUrl)\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const isLast = i === urls.length - 1\n    let response\n    try {\n      response = await fetch(url)\n    } catch (error) {\n      console.debug('Failed to fetch list', listUrl, error)\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`)\n      continue\n    }\n\n    if (!response.ok) {\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`)\n      continue\n    }\n\n    const json = await response.json()\n    if (!tokenListValidator(json)) {\n      const validationErrors: string =\n        tokenListValidator.errors?.reduce<string>((memo, error) => {\n          const add = `${error.dataPath} ${error.message ?? ''}`\n          return memo.length > 0 ? `${memo}; ${add}` : `${add}`\n        }, '') ?? 'unknown error'\n      throw new Error(`Token list failed validation: ${validationErrors}`)\n    }\n    return json\n  }\n  throw new Error('Unrecognized list URL protocol.')\n}\n"]},"metadata":{},"sourceType":"module"}