{"ast":null,"code":"var _jsxFileName = \"/Users/macbook/Desktop/Pega/pegaswap-docs/src/contexts/User.js\";\nimport React, { createContext, useContext, useReducer, useMemo, useCallback, useEffect, useState } from 'react';\nimport { useAllPairData, usePairData } from './PairData';\nimport { client, stakingClient } from '../apollo/client';\nimport { USER_TRANSACTIONS, USER_POSITIONS, USER_HISTORY, PAIR_DAY_DATA_BULK, MINING_POSITIONS } from '../apollo/queries';\nimport { useTimeframe, useStartTimestamp } from './Application';\nimport dayjs from 'dayjs';\nimport utc from 'dayjs/plugin/utc';\nimport { useEthPrice } from './GlobalData';\nimport { getLPReturnsOnPair, getHistoricalPairReturns } from '../utils/returns';\nimport { timeframeOptions } from '../constants';\ndayjs.extend(utc);\nconst UPDATE_TRANSACTIONS = 'UPDATE_TRANSACTIONS';\nconst UPDATE_POSITIONS = 'UPDATE_POSITIONS ';\nconst UPDATE_MINING_POSITIONS = 'UPDATE_MINING_POSITIONS';\nconst UPDATE_USER_POSITION_HISTORY = 'UPDATE_USER_POSITION_HISTORY';\nconst UPDATE_USER_PAIR_RETURNS = 'UPDATE_USER_PAIR_RETURNS';\nconst TRANSACTIONS_KEY = 'TRANSACTIONS_KEY';\nconst POSITIONS_KEY = 'POSITIONS_KEY';\nconst MINING_POSITIONS_KEY = 'MINING_POSITIONS_KEY';\nconst USER_SNAPSHOTS = 'USER_SNAPSHOTS';\nconst USER_PAIR_RETURNS_KEY = 'USER_PAIR_RETURNS_KEY';\nconst UserContext = createContext();\n\nfunction useUserContext() {\n  return useContext(UserContext);\n}\n\nfunction reducer(state, {\n  type,\n  payload\n}) {\n  switch (type) {\n    case UPDATE_TRANSACTIONS:\n      {\n        const {\n          account,\n          transactions\n        } = payload;\n        return { ...state,\n          [account]: { ...(state === null || state === void 0 ? void 0 : state[account]),\n            [TRANSACTIONS_KEY]: transactions\n          }\n        };\n      }\n\n    case UPDATE_POSITIONS:\n      {\n        const {\n          account,\n          positions\n        } = payload;\n        return { ...state,\n          [account]: { ...(state === null || state === void 0 ? void 0 : state[account]),\n            [POSITIONS_KEY]: positions\n          }\n        };\n      }\n\n    case UPDATE_MINING_POSITIONS:\n      {\n        const {\n          account,\n          miningPositions\n        } = payload;\n        return { ...state,\n          [account]: { ...(state === null || state === void 0 ? void 0 : state[account]),\n            [MINING_POSITIONS_KEY]: miningPositions\n          }\n        };\n      }\n\n    case UPDATE_USER_POSITION_HISTORY:\n      {\n        const {\n          account,\n          historyData\n        } = payload;\n        return { ...state,\n          [account]: { ...(state === null || state === void 0 ? void 0 : state[account]),\n            [USER_SNAPSHOTS]: historyData\n          }\n        };\n      }\n\n    case UPDATE_USER_PAIR_RETURNS:\n      {\n        var _state$account;\n\n        const {\n          account,\n          pairAddress,\n          data\n        } = payload;\n        return { ...state,\n          [account]: { ...(state === null || state === void 0 ? void 0 : state[account]),\n            [USER_PAIR_RETURNS_KEY]: { ...(state === null || state === void 0 ? void 0 : (_state$account = state[account]) === null || _state$account === void 0 ? void 0 : _state$account[USER_PAIR_RETURNS_KEY]),\n              [pairAddress]: data\n            }\n          }\n        };\n      }\n\n    default:\n      {\n        throw Error(`Unexpected action type in DataContext reducer: '${type}'.`);\n      }\n  }\n}\n\nconst INITIAL_STATE = {};\nexport default function Provider({\n  children\n}) {\n  const [state, dispatch] = useReducer(reducer, INITIAL_STATE);\n  const updateTransactions = useCallback((account, transactions) => {\n    dispatch({\n      type: UPDATE_TRANSACTIONS,\n      payload: {\n        account,\n        transactions\n      }\n    });\n  }, []);\n  const updatePositions = useCallback((account, positions) => {\n    dispatch({\n      type: UPDATE_POSITIONS,\n      payload: {\n        account,\n        positions\n      }\n    });\n  }, []);\n  const updateMiningPositions = useCallback((account, miningPositions) => {\n    dispatch({\n      type: UPDATE_MINING_POSITIONS,\n      payload: {\n        account,\n        miningPositions\n      }\n    });\n  }, []);\n  const updateUserSnapshots = useCallback((account, historyData) => {\n    dispatch({\n      type: UPDATE_USER_POSITION_HISTORY,\n      payload: {\n        account,\n        historyData\n      }\n    });\n  }, []);\n  const updateUserPairReturns = useCallback((account, pairAddress, data) => {\n    dispatch({\n      type: UPDATE_USER_PAIR_RETURNS,\n      payload: {\n        account,\n        pairAddress,\n        data\n      }\n    });\n  }, []);\n  return /*#__PURE__*/React.createElement(UserContext.Provider, {\n    value: useMemo(() => [state, {\n      updateTransactions,\n      updatePositions,\n      updateMiningPositions,\n      updateUserSnapshots,\n      updateUserPairReturns\n    }], [state, updateTransactions, updatePositions, updateMiningPositions, updateUserSnapshots, updateUserPairReturns]),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 149,\n      columnNumber: 5\n    }\n  }, children);\n}\nexport function useUserTransactions(account) {\n  var _state$account2;\n\n  const [state, {\n    updateTransactions\n  }] = useUserContext();\n  const transactions = state === null || state === void 0 ? void 0 : (_state$account2 = state[account]) === null || _state$account2 === void 0 ? void 0 : _state$account2[TRANSACTIONS_KEY];\n  useEffect(() => {\n    async function fetchData(account) {\n      try {\n        let result = await client.query({\n          query: USER_TRANSACTIONS,\n          variables: {\n            user: account\n          },\n          fetchPolicy: 'no-cache'\n        });\n\n        if (result === null || result === void 0 ? void 0 : result.data) {\n          updateTransactions(account, result === null || result === void 0 ? void 0 : result.data);\n        }\n      } catch (e) {\n        console.log(e);\n      }\n    }\n\n    if (!transactions && account) {\n      fetchData(account);\n    }\n  }, [account, transactions, updateTransactions]);\n  return transactions || {};\n}\n/**\n * Store all the snapshots of liquidity activity for this account.\n * Each snapshot is a moment when an LP position was created or updated.\n * @param {*} account\n */\n\nexport function useUserSnapshots(account) {\n  var _state$account3;\n\n  const [state, {\n    updateUserSnapshots\n  }] = useUserContext();\n  const snapshots = state === null || state === void 0 ? void 0 : (_state$account3 = state[account]) === null || _state$account3 === void 0 ? void 0 : _state$account3[USER_SNAPSHOTS];\n  useEffect(() => {\n    async function fetchData() {\n      try {\n        let skip = 0;\n        let allResults = [];\n        let found = false;\n\n        while (!found) {\n          let result = await client.query({\n            query: USER_HISTORY,\n            variables: {\n              skip: skip,\n              user: account\n            },\n            fetchPolicy: 'cache-first'\n          });\n          allResults = allResults.concat(result.data.liquidityPositionSnapshots);\n\n          if (result.data.liquidityPositionSnapshots.length < 1000) {\n            found = true;\n          } else {\n            skip += 1000;\n          }\n        }\n\n        if (allResults) {\n          updateUserSnapshots(account, allResults);\n        }\n      } catch (e) {\n        console.log(e);\n      }\n    }\n\n    if (!snapshots && account) {\n      fetchData();\n    }\n  }, [account, snapshots, updateUserSnapshots]);\n  return snapshots;\n}\n/**\n * For a given position (data about holding) and user, get the chart\n * data for the fees and liquidity over time\n * @param {*} position\n * @param {*} account\n */\n\nexport function useUserPositionChart(position, account) {\n  var _position$pair, _state$account4, _state$account4$USER_;\n\n  const pairAddress = position === null || position === void 0 ? void 0 : (_position$pair = position.pair) === null || _position$pair === void 0 ? void 0 : _position$pair.id;\n  const [state, {\n    updateUserPairReturns\n  }] = useUserContext(); // get oldest date of data to fetch\n\n  const startDateTimestamp = useStartTimestamp(); // get users adds and removes on this pair\n\n  const snapshots = useUserSnapshots(account);\n  const pairSnapshots = snapshots && position && snapshots.filter(currentSnapshot => {\n    return currentSnapshot.pair.id === position.pair.id;\n  }); // get data needed for calculations\n\n  const currentPairData = usePairData(pairAddress);\n  const [currentETHPrice] = useEthPrice(); // formatetd array to return for chart data\n\n  const formattedHistory = state === null || state === void 0 ? void 0 : (_state$account4 = state[account]) === null || _state$account4 === void 0 ? void 0 : (_state$account4$USER_ = _state$account4[USER_PAIR_RETURNS_KEY]) === null || _state$account4$USER_ === void 0 ? void 0 : _state$account4$USER_[pairAddress];\n  useEffect(() => {\n    async function fetchData() {\n      let fetchedData = await getHistoricalPairReturns(startDateTimestamp, currentPairData, pairSnapshots, currentETHPrice);\n      updateUserPairReturns(account, pairAddress, fetchedData);\n    }\n\n    if (account && startDateTimestamp && pairSnapshots && !formattedHistory && currentPairData && Object.keys(currentPairData).length > 0 && pairAddress && currentETHPrice) {\n      fetchData();\n    }\n  }, [account, startDateTimestamp, pairSnapshots, formattedHistory, pairAddress, currentPairData, currentETHPrice, updateUserPairReturns, position.pair.id]);\n  return formattedHistory;\n}\n/**\n * For each day starting with min(first position timestamp, beginning of time window),\n * get total liquidity supplied by user in USD. Format in array with date timestamps\n * and usd liquidity value.\n */\n\nexport function useUserLiquidityChart(account) {\n  const history = useUserSnapshots(account); // formatetd array to return for chart data\n\n  const [formattedHistory, setFormattedHistory] = useState();\n  const [startDateTimestamp, setStartDateTimestamp] = useState();\n  const [activeWindow] = useTimeframe(); // monitor the old date fetched\n\n  useEffect(() => {\n    const utcEndTime = dayjs.utc(); // based on window, get starttime\n\n    let utcStartTime;\n\n    switch (activeWindow) {\n      case timeframeOptions.WEEK:\n        utcStartTime = utcEndTime.subtract(1, 'week').startOf('day');\n        break;\n\n      case timeframeOptions.ALL_TIME:\n        utcStartTime = utcEndTime.subtract(1, 'year');\n        break;\n\n      default:\n        utcStartTime = utcEndTime.subtract(1, 'year').startOf('year');\n        break;\n    }\n\n    let startTime = utcStartTime.unix() - 1;\n\n    if (activeWindow && startTime < startDateTimestamp || !startDateTimestamp) {\n      setStartDateTimestamp(startTime);\n    }\n  }, [activeWindow, startDateTimestamp]);\n  useEffect(() => {\n    async function fetchData() {\n      let dayIndex = parseInt(startDateTimestamp / 86400); // get unique day bucket unix\n\n      const currentDayIndex = parseInt(dayjs.utc().unix() / 86400); // sort snapshots in order\n\n      let sortedPositions = history.sort((a, b) => {\n        return parseInt(a.timestamp) > parseInt(b.timestamp) ? 1 : -1;\n      }); // if UI start time is > first position time - bump start index to this time\n\n      if (parseInt(sortedPositions[0].timestamp) > dayIndex) {\n        dayIndex = parseInt(parseInt(sortedPositions[0].timestamp) / 86400);\n      }\n\n      const dayTimestamps = []; // get date timestamps for all days in view\n\n      while (dayIndex < currentDayIndex) {\n        dayTimestamps.push(parseInt(dayIndex) * 86400);\n        dayIndex = dayIndex + 1;\n      }\n\n      const pairs = history.reduce((pairList, position) => {\n        return [...pairList, position.pair.id];\n      }, []); // get all day datas where date is in this list, and pair is in pair list\n\n      let {\n        data: {\n          pairDayDatas\n        }\n      } = await client.query({\n        query: PAIR_DAY_DATA_BULK(pairs, startDateTimestamp)\n      });\n      const formattedHistory = []; // map of current pair => ownership %\n\n      const ownershipPerPair = {};\n\n      for (const index in dayTimestamps) {\n        const dayTimestamp = dayTimestamps[index];\n        const timestampCeiling = dayTimestamp + 86400; // cycle through relevant positions and update ownership for any that we need to\n\n        const relevantPositions = history.filter(snapshot => {\n          return snapshot.timestamp < timestampCeiling && snapshot.timestamp > dayTimestamp;\n        });\n\n        for (const index in relevantPositions) {\n          const position = relevantPositions[index]; // case where pair not added yet\n\n          if (!ownershipPerPair[position.pair.id]) {\n            ownershipPerPair[position.pair.id] = {\n              lpTokenBalance: position.liquidityTokenBalance,\n              timestamp: position.timestamp\n            };\n          } // case where more recent timestamp is found for pair\n\n\n          if (ownershipPerPair[position.pair.id] && ownershipPerPair[position.pair.id].timestamp < position.timestamp) {\n            ownershipPerPair[position.pair.id] = {\n              lpTokenBalance: position.liquidityTokenBalance,\n              timestamp: position.timestamp\n            };\n          }\n        }\n\n        const relavantDayDatas = Object.keys(ownershipPerPair).map(pairAddress => {\n          // find last day data after timestamp update\n          const dayDatasForThisPair = pairDayDatas.filter(dayData => {\n            return dayData.pairAddress === pairAddress;\n          }); // find the most recent reference to pair liquidity data\n\n          let mostRecent = dayDatasForThisPair[0];\n\n          for (const index in dayDatasForThisPair) {\n            const dayData = dayDatasForThisPair[index];\n\n            if (dayData.date < dayTimestamp && dayData.date > mostRecent.date) {\n              mostRecent = dayData;\n            }\n          }\n\n          return mostRecent;\n        }); // now cycle through pair day datas, for each one find usd value = ownership[address] * reserveUSD\n\n        const dailyUSD = relavantDayDatas.reduce((totalUSD, dayData) => {\n          if (dayData) {\n            return totalUSD = totalUSD + (ownershipPerPair[dayData.pairAddress] ? parseFloat(ownershipPerPair[dayData.pairAddress].lpTokenBalance) / parseFloat(dayData.totalSupply) * parseFloat(dayData.reserveUSD) : 0);\n          } else {\n            return totalUSD;\n          }\n        }, 0);\n        formattedHistory.push({\n          date: dayTimestamp,\n          valueUSD: dailyUSD\n        });\n      }\n\n      setFormattedHistory(formattedHistory);\n    }\n\n    if (history && startDateTimestamp && history.length > 0) {\n      fetchData();\n    }\n  }, [history, startDateTimestamp]);\n  return formattedHistory;\n}\nexport function useUserPositions(account) {\n  var _state$account5;\n\n  const [state, {\n    updatePositions\n  }] = useUserContext();\n  const positions = state === null || state === void 0 ? void 0 : (_state$account5 = state[account]) === null || _state$account5 === void 0 ? void 0 : _state$account5[POSITIONS_KEY];\n  const snapshots = useUserSnapshots(account);\n  const [ethPrice] = useEthPrice();\n  useEffect(() => {\n    async function fetchData(account) {\n      try {\n        var _result$data;\n\n        let result = await client.query({\n          query: USER_POSITIONS,\n          variables: {\n            user: account\n          },\n          fetchPolicy: 'no-cache'\n        });\n\n        if (result === null || result === void 0 ? void 0 : (_result$data = result.data) === null || _result$data === void 0 ? void 0 : _result$data.liquidityPositions) {\n          var _result$data2;\n\n          let formattedPositions = await Promise.all(result === null || result === void 0 ? void 0 : (_result$data2 = result.data) === null || _result$data2 === void 0 ? void 0 : _result$data2.liquidityPositions.map(async positionData => {\n            const returnData = await getLPReturnsOnPair(account, positionData.pair, ethPrice, snapshots);\n            return { ...positionData,\n              ...returnData\n            };\n          }));\n          updatePositions(account, formattedPositions);\n        }\n      } catch (e) {\n        console.log(e);\n      }\n    }\n\n    if (!positions && account && ethPrice && snapshots) {\n      fetchData(account);\n    }\n  }, [account, positions, updatePositions, ethPrice, snapshots]);\n  return positions;\n}\nexport function useMiningPositions(account) {\n  var _state$account6;\n\n  const [state, {\n    updateMiningPositions\n  }] = useUserContext();\n  const allPairData = useAllPairData();\n  const miningPositions = state === null || state === void 0 ? void 0 : (_state$account6 = state[account]) === null || _state$account6 === void 0 ? void 0 : _state$account6[MINING_POSITIONS_KEY];\n  const snapshots = useUserSnapshots(account);\n  useEffect(() => {\n    async function fetchData(account) {\n      try {\n        var _result$data3, _result$data3$user;\n\n        let miningPositionData = [];\n        let result = await stakingClient.query({\n          query: MINING_POSITIONS(account),\n          fetchPolicy: 'no-cache'\n        });\n\n        if (!(result === null || result === void 0 ? void 0 : (_result$data3 = result.data) === null || _result$data3 === void 0 ? void 0 : (_result$data3$user = _result$data3.user) === null || _result$data3$user === void 0 ? void 0 : _result$data3$user.miningPosition)) {\n          return;\n        }\n\n        miningPositionData = result.data.user.miningPosition;\n\n        for (const miningPosition of miningPositionData) {\n          const pairAddress = miningPosition.miningPool.pair.id;\n          miningPosition.pairData = allPairData[pairAddress];\n        }\n\n        updateMiningPositions(account, miningPositionData);\n      } catch (e) {\n        console.log(e);\n      }\n    }\n\n    if (!miningPositions && account && snapshots) {\n      fetchData(account);\n    }\n  }, [account, miningPositions, updateMiningPositions, snapshots, allPairData]);\n  return miningPositions;\n}","map":{"version":3,"sources":["/Users/macbook/Desktop/Pega/pegaswap-docs/src/contexts/User.js"],"names":["React","createContext","useContext","useReducer","useMemo","useCallback","useEffect","useState","useAllPairData","usePairData","client","stakingClient","USER_TRANSACTIONS","USER_POSITIONS","USER_HISTORY","PAIR_DAY_DATA_BULK","MINING_POSITIONS","useTimeframe","useStartTimestamp","dayjs","utc","useEthPrice","getLPReturnsOnPair","getHistoricalPairReturns","timeframeOptions","extend","UPDATE_TRANSACTIONS","UPDATE_POSITIONS","UPDATE_MINING_POSITIONS","UPDATE_USER_POSITION_HISTORY","UPDATE_USER_PAIR_RETURNS","TRANSACTIONS_KEY","POSITIONS_KEY","MINING_POSITIONS_KEY","USER_SNAPSHOTS","USER_PAIR_RETURNS_KEY","UserContext","useUserContext","reducer","state","type","payload","account","transactions","positions","miningPositions","historyData","pairAddress","data","Error","INITIAL_STATE","Provider","children","dispatch","updateTransactions","updatePositions","updateMiningPositions","updateUserSnapshots","updateUserPairReturns","useUserTransactions","fetchData","result","query","variables","user","fetchPolicy","e","console","log","useUserSnapshots","snapshots","skip","allResults","found","concat","liquidityPositionSnapshots","length","useUserPositionChart","position","pair","id","startDateTimestamp","pairSnapshots","filter","currentSnapshot","currentPairData","currentETHPrice","formattedHistory","fetchedData","Object","keys","useUserLiquidityChart","history","setFormattedHistory","setStartDateTimestamp","activeWindow","utcEndTime","utcStartTime","WEEK","subtract","startOf","ALL_TIME","startTime","unix","dayIndex","parseInt","currentDayIndex","sortedPositions","sort","a","b","timestamp","dayTimestamps","push","pairs","reduce","pairList","pairDayDatas","ownershipPerPair","index","dayTimestamp","timestampCeiling","relevantPositions","snapshot","lpTokenBalance","liquidityTokenBalance","relavantDayDatas","map","dayDatasForThisPair","dayData","mostRecent","date","dailyUSD","totalUSD","parseFloat","totalSupply","reserveUSD","valueUSD","useUserPositions","ethPrice","liquidityPositions","formattedPositions","Promise","all","positionData","returnData","useMiningPositions","allPairData","miningPositionData","miningPosition","miningPool","pairData"],"mappings":"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","sourcesContent":["import React, { createContext, useContext, useReducer, useMemo, useCallback, useEffect, useState } from 'react'\nimport { useAllPairData, usePairData } from './PairData'\nimport { client, stakingClient } from '../apollo/client'\nimport {\n  USER_TRANSACTIONS,\n  USER_POSITIONS,\n  USER_HISTORY,\n  PAIR_DAY_DATA_BULK,\n  MINING_POSITIONS,\n} from '../apollo/queries'\nimport { useTimeframe, useStartTimestamp } from './Application'\nimport dayjs from 'dayjs'\nimport utc from 'dayjs/plugin/utc'\nimport { useEthPrice } from './GlobalData'\nimport { getLPReturnsOnPair, getHistoricalPairReturns } from '../utils/returns'\nimport { timeframeOptions } from '../constants'\n\ndayjs.extend(utc)\n\nconst UPDATE_TRANSACTIONS = 'UPDATE_TRANSACTIONS'\nconst UPDATE_POSITIONS = 'UPDATE_POSITIONS '\nconst UPDATE_MINING_POSITIONS = 'UPDATE_MINING_POSITIONS'\nconst UPDATE_USER_POSITION_HISTORY = 'UPDATE_USER_POSITION_HISTORY'\nconst UPDATE_USER_PAIR_RETURNS = 'UPDATE_USER_PAIR_RETURNS'\n\nconst TRANSACTIONS_KEY = 'TRANSACTIONS_KEY'\nconst POSITIONS_KEY = 'POSITIONS_KEY'\nconst MINING_POSITIONS_KEY = 'MINING_POSITIONS_KEY'\nconst USER_SNAPSHOTS = 'USER_SNAPSHOTS'\nconst USER_PAIR_RETURNS_KEY = 'USER_PAIR_RETURNS_KEY'\n\nconst UserContext = createContext()\n\nfunction useUserContext() {\n  return useContext(UserContext)\n}\n\nfunction reducer(state, { type, payload }) {\n  switch (type) {\n    case UPDATE_TRANSACTIONS: {\n      const { account, transactions } = payload\n      return {\n        ...state,\n        [account]: {\n          ...state?.[account],\n          [TRANSACTIONS_KEY]: transactions,\n        },\n      }\n    }\n    case UPDATE_POSITIONS: {\n      const { account, positions } = payload\n      return {\n        ...state,\n        [account]: { ...state?.[account], [POSITIONS_KEY]: positions },\n      }\n    }\n    case UPDATE_MINING_POSITIONS: {\n      const { account, miningPositions } = payload\n      return {\n        ...state,\n        [account]: { ...state?.[account], [MINING_POSITIONS_KEY]: miningPositions },\n      }\n    }\n    case UPDATE_USER_POSITION_HISTORY: {\n      const { account, historyData } = payload\n      return {\n        ...state,\n        [account]: { ...state?.[account], [USER_SNAPSHOTS]: historyData },\n      }\n    }\n\n    case UPDATE_USER_PAIR_RETURNS: {\n      const { account, pairAddress, data } = payload\n      return {\n        ...state,\n        [account]: {\n          ...state?.[account],\n          [USER_PAIR_RETURNS_KEY]: {\n            ...state?.[account]?.[USER_PAIR_RETURNS_KEY],\n            [pairAddress]: data,\n          },\n        },\n      }\n    }\n\n    default: {\n      throw Error(`Unexpected action type in DataContext reducer: '${type}'.`)\n    }\n  }\n}\n\nconst INITIAL_STATE = {}\n\nexport default function Provider({ children }) {\n  const [state, dispatch] = useReducer(reducer, INITIAL_STATE)\n\n  const updateTransactions = useCallback((account, transactions) => {\n    dispatch({\n      type: UPDATE_TRANSACTIONS,\n      payload: {\n        account,\n        transactions,\n      },\n    })\n  }, [])\n\n  const updatePositions = useCallback((account, positions) => {\n    dispatch({\n      type: UPDATE_POSITIONS,\n      payload: {\n        account,\n        positions,\n      },\n    })\n  }, [])\n\n  const updateMiningPositions = useCallback((account, miningPositions) => {\n    dispatch({\n      type: UPDATE_MINING_POSITIONS,\n      payload: {\n        account,\n        miningPositions,\n      },\n    })\n  }, [])\n\n  const updateUserSnapshots = useCallback((account, historyData) => {\n    dispatch({\n      type: UPDATE_USER_POSITION_HISTORY,\n      payload: {\n        account,\n        historyData,\n      },\n    })\n  }, [])\n\n  const updateUserPairReturns = useCallback((account, pairAddress, data) => {\n    dispatch({\n      type: UPDATE_USER_PAIR_RETURNS,\n      payload: {\n        account,\n        pairAddress,\n        data,\n      },\n    })\n  }, [])\n\n  return (\n    <UserContext.Provider\n      value={useMemo(\n        () => [\n          state,\n          { updateTransactions, updatePositions, updateMiningPositions, updateUserSnapshots, updateUserPairReturns },\n        ],\n        [state, updateTransactions, updatePositions, updateMiningPositions, updateUserSnapshots, updateUserPairReturns]\n      )}\n    >\n      {children}\n    </UserContext.Provider>\n  )\n}\n\nexport function useUserTransactions(account) {\n  const [state, { updateTransactions }] = useUserContext()\n  const transactions = state?.[account]?.[TRANSACTIONS_KEY]\n  useEffect(() => {\n    async function fetchData(account) {\n      try {\n        let result = await client.query({\n          query: USER_TRANSACTIONS,\n          variables: {\n            user: account,\n          },\n          fetchPolicy: 'no-cache',\n        })\n        if (result?.data) {\n          updateTransactions(account, result?.data)\n        }\n      } catch (e) {\n        console.log(e)\n      }\n    }\n    if (!transactions && account) {\n      fetchData(account)\n    }\n  }, [account, transactions, updateTransactions])\n\n  return transactions || {}\n}\n\n/**\n * Store all the snapshots of liquidity activity for this account.\n * Each snapshot is a moment when an LP position was created or updated.\n * @param {*} account\n */\nexport function useUserSnapshots(account) {\n  const [state, { updateUserSnapshots }] = useUserContext()\n  const snapshots = state?.[account]?.[USER_SNAPSHOTS]\n\n  useEffect(() => {\n    async function fetchData() {\n      try {\n        let skip = 0\n        let allResults = []\n        let found = false\n        while (!found) {\n          let result = await client.query({\n            query: USER_HISTORY,\n            variables: {\n              skip: skip,\n              user: account,\n            },\n            fetchPolicy: 'cache-first',\n          })\n          allResults = allResults.concat(result.data.liquidityPositionSnapshots)\n          if (result.data.liquidityPositionSnapshots.length < 1000) {\n            found = true\n          } else {\n            skip += 1000\n          }\n        }\n        if (allResults) {\n          updateUserSnapshots(account, allResults)\n        }\n      } catch (e) {\n        console.log(e)\n      }\n    }\n    if (!snapshots && account) {\n      fetchData()\n    }\n  }, [account, snapshots, updateUserSnapshots])\n\n  return snapshots\n}\n\n/**\n * For a given position (data about holding) and user, get the chart\n * data for the fees and liquidity over time\n * @param {*} position\n * @param {*} account\n */\nexport function useUserPositionChart(position, account) {\n  const pairAddress = position?.pair?.id\n  const [state, { updateUserPairReturns }] = useUserContext()\n\n  // get oldest date of data to fetch\n  const startDateTimestamp = useStartTimestamp()\n\n  // get users adds and removes on this pair\n  const snapshots = useUserSnapshots(account)\n  const pairSnapshots =\n    snapshots &&\n    position &&\n    snapshots.filter((currentSnapshot) => {\n      return currentSnapshot.pair.id === position.pair.id\n    })\n\n  // get data needed for calculations\n  const currentPairData = usePairData(pairAddress)\n  const [currentETHPrice] = useEthPrice()\n\n  // formatetd array to return for chart data\n  const formattedHistory = state?.[account]?.[USER_PAIR_RETURNS_KEY]?.[pairAddress]\n\n  useEffect(() => {\n    async function fetchData() {\n      let fetchedData = await getHistoricalPairReturns(\n        startDateTimestamp,\n        currentPairData,\n        pairSnapshots,\n        currentETHPrice\n      )\n      updateUserPairReturns(account, pairAddress, fetchedData)\n    }\n    if (\n      account &&\n      startDateTimestamp &&\n      pairSnapshots &&\n      !formattedHistory &&\n      currentPairData &&\n      Object.keys(currentPairData).length > 0 &&\n      pairAddress &&\n      currentETHPrice\n    ) {\n      fetchData()\n    }\n  }, [\n    account,\n    startDateTimestamp,\n    pairSnapshots,\n    formattedHistory,\n    pairAddress,\n    currentPairData,\n    currentETHPrice,\n    updateUserPairReturns,\n    position.pair.id,\n  ])\n\n  return formattedHistory\n}\n\n/**\n * For each day starting with min(first position timestamp, beginning of time window),\n * get total liquidity supplied by user in USD. Format in array with date timestamps\n * and usd liquidity value.\n */\nexport function useUserLiquidityChart(account) {\n  const history = useUserSnapshots(account)\n  // formatetd array to return for chart data\n  const [formattedHistory, setFormattedHistory] = useState()\n\n  const [startDateTimestamp, setStartDateTimestamp] = useState()\n  const [activeWindow] = useTimeframe()\n\n  // monitor the old date fetched\n  useEffect(() => {\n    const utcEndTime = dayjs.utc()\n    // based on window, get starttime\n    let utcStartTime\n    switch (activeWindow) {\n      case timeframeOptions.WEEK:\n        utcStartTime = utcEndTime.subtract(1, 'week').startOf('day')\n        break\n      case timeframeOptions.ALL_TIME:\n        utcStartTime = utcEndTime.subtract(1, 'year')\n        break\n      default:\n        utcStartTime = utcEndTime.subtract(1, 'year').startOf('year')\n        break\n    }\n    let startTime = utcStartTime.unix() - 1\n    if ((activeWindow && startTime < startDateTimestamp) || !startDateTimestamp) {\n      setStartDateTimestamp(startTime)\n    }\n  }, [activeWindow, startDateTimestamp])\n\n  useEffect(() => {\n    async function fetchData() {\n      let dayIndex = parseInt(startDateTimestamp / 86400) // get unique day bucket unix\n      const currentDayIndex = parseInt(dayjs.utc().unix() / 86400)\n\n      // sort snapshots in order\n      let sortedPositions = history.sort((a, b) => {\n        return parseInt(a.timestamp) > parseInt(b.timestamp) ? 1 : -1\n      })\n      // if UI start time is > first position time - bump start index to this time\n      if (parseInt(sortedPositions[0].timestamp) > dayIndex) {\n        dayIndex = parseInt(parseInt(sortedPositions[0].timestamp) / 86400)\n      }\n\n      const dayTimestamps = []\n      // get date timestamps for all days in view\n      while (dayIndex < currentDayIndex) {\n        dayTimestamps.push(parseInt(dayIndex) * 86400)\n        dayIndex = dayIndex + 1\n      }\n\n      const pairs = history.reduce((pairList, position) => {\n        return [...pairList, position.pair.id]\n      }, [])\n\n      // get all day datas where date is in this list, and pair is in pair list\n      let {\n        data: { pairDayDatas },\n      } = await client.query({\n        query: PAIR_DAY_DATA_BULK(pairs, startDateTimestamp),\n      })\n\n      const formattedHistory = []\n\n      // map of current pair => ownership %\n      const ownershipPerPair = {}\n      for (const index in dayTimestamps) {\n        const dayTimestamp = dayTimestamps[index]\n        const timestampCeiling = dayTimestamp + 86400\n\n        // cycle through relevant positions and update ownership for any that we need to\n        const relevantPositions = history.filter((snapshot) => {\n          return snapshot.timestamp < timestampCeiling && snapshot.timestamp > dayTimestamp\n        })\n        for (const index in relevantPositions) {\n          const position = relevantPositions[index]\n          // case where pair not added yet\n          if (!ownershipPerPair[position.pair.id]) {\n            ownershipPerPair[position.pair.id] = {\n              lpTokenBalance: position.liquidityTokenBalance,\n              timestamp: position.timestamp,\n            }\n          }\n          // case where more recent timestamp is found for pair\n          if (ownershipPerPair[position.pair.id] && ownershipPerPair[position.pair.id].timestamp < position.timestamp) {\n            ownershipPerPair[position.pair.id] = {\n              lpTokenBalance: position.liquidityTokenBalance,\n              timestamp: position.timestamp,\n            }\n          }\n        }\n\n        const relavantDayDatas = Object.keys(ownershipPerPair).map((pairAddress) => {\n          // find last day data after timestamp update\n          const dayDatasForThisPair = pairDayDatas.filter((dayData) => {\n            return dayData.pairAddress === pairAddress\n          })\n          // find the most recent reference to pair liquidity data\n          let mostRecent = dayDatasForThisPair[0]\n          for (const index in dayDatasForThisPair) {\n            const dayData = dayDatasForThisPair[index]\n            if (dayData.date < dayTimestamp && dayData.date > mostRecent.date) {\n              mostRecent = dayData\n            }\n          }\n          return mostRecent\n        })\n\n        // now cycle through pair day datas, for each one find usd value = ownership[address] * reserveUSD\n        const dailyUSD = relavantDayDatas.reduce((totalUSD, dayData) => {\n          if (dayData) {\n            return (totalUSD =\n              totalUSD +\n              (ownershipPerPair[dayData.pairAddress]\n                ? (parseFloat(ownershipPerPair[dayData.pairAddress].lpTokenBalance) / parseFloat(dayData.totalSupply)) *\n                  parseFloat(dayData.reserveUSD)\n                : 0))\n          } else {\n            return totalUSD\n          }\n        }, 0)\n\n        formattedHistory.push({\n          date: dayTimestamp,\n          valueUSD: dailyUSD,\n        })\n      }\n\n      setFormattedHistory(formattedHistory)\n    }\n    if (history && startDateTimestamp && history.length > 0) {\n      fetchData()\n    }\n  }, [history, startDateTimestamp])\n\n  return formattedHistory\n}\n\nexport function useUserPositions(account) {\n  const [state, { updatePositions }] = useUserContext()\n  const positions = state?.[account]?.[POSITIONS_KEY]\n\n  const snapshots = useUserSnapshots(account)\n  const [ethPrice] = useEthPrice()\n\n  useEffect(() => {\n    async function fetchData(account) {\n      try {\n        let result = await client.query({\n          query: USER_POSITIONS,\n          variables: {\n            user: account,\n          },\n          fetchPolicy: 'no-cache',\n        })\n        if (result?.data?.liquidityPositions) {\n          let formattedPositions = await Promise.all(\n            result?.data?.liquidityPositions.map(async (positionData) => {\n              const returnData = await getLPReturnsOnPair(account, positionData.pair, ethPrice, snapshots)\n              return {\n                ...positionData,\n                ...returnData,\n              }\n            })\n          )\n          updatePositions(account, formattedPositions)\n        }\n      } catch (e) {\n        console.log(e)\n      }\n    }\n    if (!positions && account && ethPrice && snapshots) {\n      fetchData(account)\n    }\n  }, [account, positions, updatePositions, ethPrice, snapshots])\n\n  return positions\n}\n\nexport function useMiningPositions(account) {\n  const [state, { updateMiningPositions }] = useUserContext()\n  const allPairData = useAllPairData()\n  const miningPositions = state?.[account]?.[MINING_POSITIONS_KEY]\n\n  const snapshots = useUserSnapshots(account)\n\n  useEffect(() => {\n    async function fetchData(account) {\n      try {\n        let miningPositionData = []\n        let result = await stakingClient.query({\n          query: MINING_POSITIONS(account),\n          fetchPolicy: 'no-cache',\n        })\n        if (!result?.data?.user?.miningPosition) {\n          return\n        }\n        miningPositionData = result.data.user.miningPosition\n        for (const miningPosition of miningPositionData) {\n          const pairAddress = miningPosition.miningPool.pair.id\n          miningPosition.pairData = allPairData[pairAddress]\n        }\n        updateMiningPositions(account, miningPositionData)\n      } catch (e) {\n        console.log(e)\n      }\n    }\n\n    if (!miningPositions && account && snapshots) {\n      fetchData(account)\n    }\n  }, [account, miningPositions, updateMiningPositions, snapshots, allPairData])\n  return miningPositions\n}\n"]},"metadata":{},"sourceType":"module"}