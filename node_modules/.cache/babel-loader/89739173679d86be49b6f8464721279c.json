{"ast":null,"code":"import _regeneratorRuntime from\"/Users/macbook/Desktop/juiceswap/juiceswap-docs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/macbook/Desktop/juiceswap/juiceswap-docs/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";/* eslint-disable */import{USER_MINTS_BUNRS_PER_PAIR}from'../apollo/queries';import{client}from'../apollo/client';import dayjs from'dayjs';import{getShareValueOverTime}from'.';export var priceOverrides=['0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',// USDC\n'0x6b175474e89094c44da98b954eedeac495271d0f'// DAI\n];var PRICE_DISCOVERY_START_TIMESTAMP=1589747086;function formatPricesForEarlyTimestamps(position){if(position.timestamp<PRICE_DISCOVERY_START_TIMESTAMP){var _position$pair,_position$pair2,_position$pair3,_position$pair4;if(priceOverrides.includes(position===null||position===void 0?void 0:(_position$pair=position.pair)===null||_position$pair===void 0?void 0:_position$pair.token0.id)){position.token0PriceUSD=1;}if(priceOverrides.includes(position===null||position===void 0?void 0:(_position$pair2=position.pair)===null||_position$pair2===void 0?void 0:_position$pair2.token1.id)){position.token1PriceUSD=1;}// WETH price\nif(((_position$pair3=position.pair)===null||_position$pair3===void 0?void 0:_position$pair3.token0.id)==='0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2'){position.token0PriceUSD=203;}if(((_position$pair4=position.pair)===null||_position$pair4===void 0?void 0:_position$pair4.token1.id)==='0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2'){position.token1PriceUSD=203;}}return position;}function getPrincipalForUserPerPair(_x,_x2){return _getPrincipalForUserPerPair.apply(this,arguments);}/**\n * Core algorithm for calculating retursn within one time window.\n * @param positionT0 // users liquidity info and token rates at beginning of window\n * @param positionT1 // '' at the end of the window\n */function _getPrincipalForUserPerPair(){_getPrincipalForUserPerPair=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(user,pairAddress){var usd,amount0,amount1,results,index,mint,mintToken0,mintToken1,_index,burn,burnToken0,burnToken1;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:usd=0;amount0=0;amount1=0;// get all minst and burns to get principal amounts\n_context.next=5;return client.query({query:USER_MINTS_BUNRS_PER_PAIR,variables:{user:user,pair:pairAddress}});case 5:results=_context.sent;for(index in results.data.mints){mint=results.data.mints[index];mintToken0=mint.pair.token0.id;mintToken1=mint.pair.token1.id;// if trackign before prices were discovered (pre-launch days), hardcode stablecoins\nif(priceOverrides.includes(mintToken0)&&mint.timestamp<PRICE_DISCOVERY_START_TIMESTAMP){usd+=parseFloat(mint.amount0)*2;}else if(priceOverrides.includes(mintToken1)&&mint.timestamp<PRICE_DISCOVERY_START_TIMESTAMP){usd+=parseFloat(mint.amount1)*2;}else{usd+=parseFloat(mint.amountUSD);}amount0+=amount0+parseFloat(mint.amount0);amount1+=amount1+parseFloat(mint.amount1);}for(_index in results.data.burns){burn=results.data.burns[_index];burnToken0=burn.pair.token0.id;burnToken1=burn.pair.token1.id;// if trackign before prices were discovered (pre-launch days), hardcode stablecoins\nif(priceOverrides.includes(burnToken0)&&burn.timestamp<PRICE_DISCOVERY_START_TIMESTAMP){usd+=parseFloat(burn.amount0)*2;}else if(priceOverrides.includes(burnToken1)&&burn.timestamp<PRICE_DISCOVERY_START_TIMESTAMP){usd+=parseFloat(burn.amount1)*2;}else{usd-=parseFloat(results.data.burns[_index].amountUSD);}amount0-=parseFloat(results.data.burns[_index].amount0);amount1-=parseFloat(results.data.burns[_index].amount1);}return _context.abrupt(\"return\",{usd:usd,amount0:amount0,amount1:amount1});case 9:case\"end\":return _context.stop();}}},_callee);}));return _getPrincipalForUserPerPair.apply(this,arguments);}export function getMetricsForPositionWindow(positionT0,positionT1){positionT0=formatPricesForEarlyTimestamps(positionT0);positionT1=formatPricesForEarlyTimestamps(positionT1);// calculate ownership at ends of window, for end of window we need original LP token balance / new total supply\nvar t0Ownership=positionT0.liquidityTokenBalance/positionT0.liquidityTokenTotalSupply;var t1Ownership=positionT0.liquidityTokenBalance/positionT1.liquidityTokenTotalSupply;// get starting amounts of token0 and token1 deposited by LP\nvar token0_amount_t0=t0Ownership*positionT0.reserve0;var token1_amount_t0=t0Ownership*positionT0.reserve1;// get current token values\nvar token0_amount_t1=t1Ownership*positionT1.reserve0;var token1_amount_t1=t1Ownership*positionT1.reserve1;// calculate squares to find imp loss and fee differences\nvar sqrK_t0=Math.sqrt(token0_amount_t0*token1_amount_t0);// eslint-disable-next-line eqeqeq\nvar priceRatioT1=positionT1.token0PriceUSD!=0?positionT1.token1PriceUSD/positionT1.token0PriceUSD:0;var token0_amount_no_fees=positionT1.token1PriceUSD&&priceRatioT1?sqrK_t0*Math.sqrt(priceRatioT1):0;var token1_amount_no_fees=Number(positionT1.token1PriceUSD)&&priceRatioT1?sqrK_t0/Math.sqrt(priceRatioT1):0;var no_fees_usd=token0_amount_no_fees*positionT1.token0PriceUSD+token1_amount_no_fees*positionT1.token1PriceUSD;var difference_fees_token0=token0_amount_t1-token0_amount_no_fees;var difference_fees_token1=token1_amount_t1-token1_amount_no_fees;var difference_fees_usd=difference_fees_token0*positionT1.token0PriceUSD+difference_fees_token1*positionT1.token1PriceUSD;// calculate USD value at t0 and t1 using initial token deposit amounts for asset return\nvar assetValueT0=token0_amount_t0*positionT0.token0PriceUSD+token1_amount_t0*positionT0.token1PriceUSD;var assetValueT1=token0_amount_t0*positionT1.token0PriceUSD+token1_amount_t0*positionT1.token1PriceUSD;var imp_loss_usd=no_fees_usd-assetValueT1;var uniswap_return=difference_fees_usd+imp_loss_usd;// get net value change for combined data\nvar netValueT0=t0Ownership*positionT0.reserveUSD;var netValueT1=t1Ownership*positionT1.reserveUSD;return{hodleReturn:assetValueT1-assetValueT0,netReturn:netValueT1-netValueT0,uniswapReturn:uniswap_return,impLoss:imp_loss_usd,fees:difference_fees_usd};}/**\n * formats data for historical chart for an LPs position in 1 pair over time\n * @param startDateTimestamp // day to start tracking at\n * @param currentPairData // current stat of the pair\n * @param pairSnapshots // history of entries and exits for lp on this pair\n * @param currentETHPrice // current price of eth used for usd conversions\n */export function getHistoricalPairReturns(_x3,_x4,_x5,_x6){return _getHistoricalPairReturns.apply(this,arguments);}/**\n * For a given pair and user, get the return metrics\n * @param user\n * @param pair\n * @param ethPrice\n */function _getHistoricalPairReturns(){_getHistoricalPairReturns=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(startDateTimestamp,currentPairData,pairSnapshots,currentETHPrice){var dayIndex,currentDayIndex,sortedPositions,dayTimestamps,shareValues,shareValuesFormatted,positionT0,formattedHistory,netFees,_loop,index;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(currentPairData.createdAtTimestamp){_context2.next=2;break;}return _context2.abrupt(\"return\",[]);case 2:dayIndex=Math.round(startDateTimestamp/86400);// get unique day bucket unix\ncurrentDayIndex=Math.round(dayjs.utc().unix()/86400);sortedPositions=pairSnapshots.sort(function(a,b){return parseInt(a.timestamp)>parseInt(b.timestamp)?1:-1;});if(sortedPositions[0].timestamp>startDateTimestamp){dayIndex=Math.round(sortedPositions[0].timestamp/86400);}dayTimestamps=[];while(dayIndex<currentDayIndex){// only account for days where this pair existed\nif(dayIndex*86400>=parseInt(currentPairData.createdAtTimestamp)){dayTimestamps.push(dayIndex*86400);}dayIndex=dayIndex+1;}_context2.next=10;return getShareValueOverTime(currentPairData.id,dayTimestamps);case 10:shareValues=_context2.sent;shareValuesFormatted={};shareValues===null||shareValues===void 0?void 0:shareValues.map(function(share){shareValuesFormatted[share.timestamp]=share;});// set the default position and data\npositionT0=pairSnapshots[0];formattedHistory=[];netFees=0;// keep track of up to date metrics as we parse each day\n_loop=function _loop(index){// get the bounds on the day\nvar dayTimestamp=dayTimestamps[index];var timestampCeiling=dayTimestamp+86400;// for each change in position value that day, create a window and update\nvar dailyChanges=pairSnapshots.filter(function(snapshot){return snapshot.timestamp<timestampCeiling&&snapshot.timestamp>dayTimestamp;});for(var i=0;i<dailyChanges.length;i++){var _positionT=dailyChanges[i];var localReturns=getMetricsForPositionWindow(positionT0,_positionT);netFees=netFees+localReturns.fees;positionT0=_positionT;}// now treat the end of the day as a hypothetical position\nvar positionT1=shareValuesFormatted[dayTimestamp+86400];if(!positionT1){positionT1={pair:currentPairData.id,liquidityTokenBalance:positionT0.liquidityTokenBalance,totalSupply:currentPairData.totalSupply,reserve0:currentPairData.reserve0,reserve1:currentPairData.reserve1,reserveUSD:currentPairData.reserveUSD,token0PriceUSD:currentPairData.token0.derivedETH*currentETHPrice,token1PriceUSD:currentPairData.token1.derivedETH*currentETHPrice};}if(positionT1){positionT1.liquidityTokenTotalSupply=positionT1.totalSupply;positionT1.liquidityTokenBalance=positionT0.liquidityTokenBalance;var currentLiquidityValue=parseFloat(positionT1.liquidityTokenBalance)/parseFloat(positionT1.liquidityTokenTotalSupply)*parseFloat(positionT1.reserveUSD);var _localReturns=getMetricsForPositionWindow(positionT0,positionT1);var localFees=netFees+_localReturns.fees;formattedHistory.push({date:dayTimestamp,usdValue:currentLiquidityValue,fees:localFees});}};for(index in dayTimestamps){_loop(index);}return _context2.abrupt(\"return\",formattedHistory);case 19:case\"end\":return _context2.stop();}}},_callee2);}));return _getHistoricalPairReturns.apply(this,arguments);}export function getLPReturnsOnPair(_x7,_x8,_x9,_x10){return _getLPReturnsOnPair.apply(this,arguments);}function _getLPReturnsOnPair(){_getLPReturnsOnPair=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(user,pair,ethPrice,snapshots){var _snapshots;var principal,hodlReturn,netReturn,uniswapReturn,fees,currentPosition,index,_positionT2,positionT1,results;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.next=2;return getPrincipalForUserPerPair(user,pair.id);case 2:principal=_context3.sent;hodlReturn=0;netReturn=0;uniswapReturn=0;fees=0;snapshots=snapshots.filter(function(entry){return entry.pair.id===pair.id;});// get data about the current position\ncurrentPosition={pair:pair,liquidityTokenBalance:(_snapshots=snapshots[snapshots.length-1])===null||_snapshots===void 0?void 0:_snapshots.liquidityTokenBalance,liquidityTokenTotalSupply:pair.totalSupply,reserve0:pair.reserve0,reserve1:pair.reserve1,reserveUSD:pair.reserveUSD,token0PriceUSD:pair.token0.derivedETH*ethPrice,token1PriceUSD:pair.token1.derivedETH*ethPrice};for(index in snapshots){// get positions at both bounds of the window\n_positionT2=snapshots[index];positionT1=parseInt(index)===snapshots.length-1?currentPosition:snapshots[parseInt(index)+1];results=getMetricsForPositionWindow(_positionT2,positionT1);hodlReturn=hodlReturn+results.hodleReturn;netReturn=netReturn+results.netReturn;uniswapReturn=uniswapReturn+results.uniswapReturn;fees=fees+results.fees;}return _context3.abrupt(\"return\",{principal:principal,net:{return:netReturn},uniswap:{return:uniswapReturn},fees:{sum:fees}});case 11:case\"end\":return _context3.stop();}}},_callee3);}));return _getLPReturnsOnPair.apply(this,arguments);}","map":{"version":3,"sources":["/Users/macbook/Desktop/juiceswap/juiceswap-docs/src/utils/returns.ts"],"names":["USER_MINTS_BUNRS_PER_PAIR","client","dayjs","getShareValueOverTime","priceOverrides","PRICE_DISCOVERY_START_TIMESTAMP","formatPricesForEarlyTimestamps","position","timestamp","includes","pair","token0","id","token0PriceUSD","token1","token1PriceUSD","getPrincipalForUserPerPair","user","pairAddress","usd","amount0","amount1","query","variables","results","index","data","mints","mint","mintToken0","mintToken1","parseFloat","amountUSD","burns","burn","burnToken0","burnToken1","getMetricsForPositionWindow","positionT0","positionT1","t0Ownership","liquidityTokenBalance","liquidityTokenTotalSupply","t1Ownership","token0_amount_t0","reserve0","token1_amount_t0","reserve1","token0_amount_t1","token1_amount_t1","sqrK_t0","Math","sqrt","priceRatioT1","token0_amount_no_fees","token1_amount_no_fees","Number","no_fees_usd","difference_fees_token0","difference_fees_token1","difference_fees_usd","assetValueT0","assetValueT1","imp_loss_usd","uniswap_return","netValueT0","reserveUSD","netValueT1","hodleReturn","netReturn","uniswapReturn","impLoss","fees","getHistoricalPairReturns","startDateTimestamp","currentPairData","pairSnapshots","currentETHPrice","createdAtTimestamp","dayIndex","round","currentDayIndex","utc","unix","sortedPositions","sort","a","b","parseInt","dayTimestamps","push","shareValues","shareValuesFormatted","map","share","formattedHistory","netFees","dayTimestamp","timestampCeiling","dailyChanges","filter","snapshot","i","length","localReturns","totalSupply","derivedETH","currentLiquidityValue","localFees","date","usdValue","getLPReturnsOnPair","ethPrice","snapshots","principal","hodlReturn","entry","currentPosition","net","return","uniswap","sum"],"mappings":"yUAAA,oBACA,OAASA,yBAAT,KAA0C,mBAA1C,CACA,OAASC,MAAT,KAAuB,kBAAvB,CACA,MAAOC,CAAAA,KAAP,KAAkB,OAAlB,CACA,OAASC,qBAAT,KAAsC,GAAtC,CAEA,MAAO,IAAMC,CAAAA,cAAc,CAAG,CAC5B,4CAD4B,CACkB;AAC9C,4CAA8C;AAFlB,CAAvB,CAyBP,GAAMC,CAAAA,+BAA+B,CAAG,UAAxC,CAEA,QAASC,CAAAA,8BAAT,CAAwCC,QAAxC,CAA4D,CAC1D,GAAIA,QAAQ,CAACC,SAAT,CAAqBH,+BAAzB,CAA0D,oEACxD,GAAID,cAAc,CAACK,QAAf,CAAwBF,QAAxB,SAAwBA,QAAxB,iCAAwBA,QAAQ,CAAEG,IAAlC,yCAAwB,eAAgBC,MAAhB,CAAuBC,EAA/C,CAAJ,CAAwD,CACtDL,QAAQ,CAACM,cAAT,CAA0B,CAA1B,CACD,CACD,GAAIT,cAAc,CAACK,QAAf,CAAwBF,QAAxB,SAAwBA,QAAxB,kCAAwBA,QAAQ,CAAEG,IAAlC,0CAAwB,gBAAgBI,MAAhB,CAAuBF,EAA/C,CAAJ,CAAwD,CACtDL,QAAQ,CAACQ,cAAT,CAA0B,CAA1B,CACD,CACD;AACA,GAAI,kBAAAR,QAAQ,CAACG,IAAT,0DAAeC,MAAf,CAAsBC,EAAtB,IAA6B,4CAAjC,CAA+E,CAC7EL,QAAQ,CAACM,cAAT,CAA0B,GAA1B,CACD,CACD,GAAI,kBAAAN,QAAQ,CAACG,IAAT,0DAAeI,MAAf,CAAsBF,EAAtB,IAA6B,4CAAjC,CAA+E,CAC7EL,QAAQ,CAACQ,cAAT,CAA0B,GAA1B,CACD,CACF,CACD,MAAOR,CAAAA,QAAP,CACD,C,QAEcS,CAAAA,0B,mEAkDf;AACA;AACA;AACA;AACA,G,2HAtDA,iBAA0CC,IAA1C,CAAwDC,WAAxD,qNACMC,GADN,CACY,CADZ,CAEMC,OAFN,CAEgB,CAFhB,CAGMC,OAHN,CAGgB,CAHhB,CAIE;AAJF,sBAKwBpB,CAAAA,MAAM,CAACqB,KAAP,CAAa,CACjCA,KAAK,CAAEtB,yBAD0B,CAEjCuB,SAAS,CAAE,CACTN,IAAI,CAAJA,IADS,CAETP,IAAI,CAAEQ,WAFG,CAFsB,CAAb,CALxB,QAKQM,OALR,eAYE,IAAWC,KAAX,GAAoBD,CAAAA,OAAO,CAACE,IAAR,CAAaC,KAAjC,CAAwC,CAChCC,IADgC,CACzBJ,OAAO,CAACE,IAAR,CAAaC,KAAb,CAAmBF,KAAnB,CADyB,CAEhCI,UAFgC,CAEnBD,IAAI,CAAClB,IAAL,CAAUC,MAAV,CAAiBC,EAFE,CAGhCkB,UAHgC,CAGnBF,IAAI,CAAClB,IAAL,CAAUI,MAAV,CAAiBF,EAHE,CAKtC;AACA,GAAIR,cAAc,CAACK,QAAf,CAAwBoB,UAAxB,GAAuCD,IAAI,CAACpB,SAAL,CAAiBH,+BAA5D,CAA6F,CAC3Fc,GAAG,EAAIY,UAAU,CAACH,IAAI,CAACR,OAAN,CAAV,CAA2B,CAAlC,CACD,CAFD,IAEO,IAAIhB,cAAc,CAACK,QAAf,CAAwBqB,UAAxB,GAAuCF,IAAI,CAACpB,SAAL,CAAiBH,+BAA5D,CAA6F,CAClGc,GAAG,EAAIY,UAAU,CAACH,IAAI,CAACP,OAAN,CAAV,CAA2B,CAAlC,CACD,CAFM,IAEA,CACLF,GAAG,EAAIY,UAAU,CAACH,IAAI,CAACI,SAAN,CAAjB,CACD,CACDZ,OAAO,EAAIA,OAAO,CAAGW,UAAU,CAACH,IAAI,CAACR,OAAN,CAA/B,CACAC,OAAO,EAAIA,OAAO,CAAGU,UAAU,CAACH,IAAI,CAACP,OAAN,CAA/B,CACD,CAED,IAAWI,MAAX,GAAoBD,CAAAA,OAAO,CAACE,IAAR,CAAaO,KAAjC,CAAwC,CAChCC,IADgC,CACzBV,OAAO,CAACE,IAAR,CAAaO,KAAb,CAAmBR,MAAnB,CADyB,CAEhCU,UAFgC,CAEnBD,IAAI,CAACxB,IAAL,CAAUC,MAAV,CAAiBC,EAFE,CAGhCwB,UAHgC,CAGnBF,IAAI,CAACxB,IAAL,CAAUI,MAAV,CAAiBF,EAHE,CAKtC;AACA,GAAIR,cAAc,CAACK,QAAf,CAAwB0B,UAAxB,GAAuCD,IAAI,CAAC1B,SAAL,CAAiBH,+BAA5D,CAA6F,CAC3Fc,GAAG,EAAIY,UAAU,CAACG,IAAI,CAACd,OAAN,CAAV,CAA2B,CAAlC,CACD,CAFD,IAEO,IAAIhB,cAAc,CAACK,QAAf,CAAwB2B,UAAxB,GAAuCF,IAAI,CAAC1B,SAAL,CAAiBH,+BAA5D,CAA6F,CAClGc,GAAG,EAAIY,UAAU,CAACG,IAAI,CAACb,OAAN,CAAV,CAA2B,CAAlC,CACD,CAFM,IAEA,CACLF,GAAG,EAAIY,UAAU,CAACP,OAAO,CAACE,IAAR,CAAaO,KAAb,CAAmBR,MAAnB,EAA0BO,SAA3B,CAAjB,CACD,CAEDZ,OAAO,EAAIW,UAAU,CAACP,OAAO,CAACE,IAAR,CAAaO,KAAb,CAAmBR,MAAnB,EAA0BL,OAA3B,CAArB,CACAC,OAAO,EAAIU,UAAU,CAACP,OAAO,CAACE,IAAR,CAAaO,KAAb,CAAmBR,MAAnB,EAA0BJ,OAA3B,CAArB,CACD,CA7CH,gCA+CS,CAAEF,GAAG,CAAHA,GAAF,CAAOC,OAAO,CAAPA,OAAP,CAAgBC,OAAO,CAAPA,OAAhB,CA/CT,wD,6DAuDA,MAAO,SAASgB,CAAAA,2BAAT,CAAqCC,UAArC,CAA2DC,UAA3D,CAAgG,CACrGD,UAAU,CAAGhC,8BAA8B,CAACgC,UAAD,CAA3C,CACAC,UAAU,CAAGjC,8BAA8B,CAACiC,UAAD,CAA3C,CAEA;AACA,GAAMC,CAAAA,WAAW,CAAGF,UAAU,CAACG,qBAAX,CAAmCH,UAAU,CAACI,yBAAlE,CACA,GAAMC,CAAAA,WAAW,CAAGL,UAAU,CAACG,qBAAX,CAAmCF,UAAU,CAACG,yBAAlE,CAEA;AACA,GAAME,CAAAA,gBAAgB,CAAGJ,WAAW,CAAGF,UAAU,CAACO,QAAlD,CACA,GAAMC,CAAAA,gBAAgB,CAAGN,WAAW,CAAGF,UAAU,CAACS,QAAlD,CAEA;AACA,GAAMC,CAAAA,gBAAgB,CAAGL,WAAW,CAAGJ,UAAU,CAACM,QAAlD,CACA,GAAMI,CAAAA,gBAAgB,CAAGN,WAAW,CAAGJ,UAAU,CAACQ,QAAlD,CAEA;AACA,GAAMG,CAAAA,OAAO,CAAGC,IAAI,CAACC,IAAL,CAAUR,gBAAgB,CAAGE,gBAA7B,CAAhB,CACA;AACA,GAAMO,CAAAA,YAAY,CAAGd,UAAU,CAAC1B,cAAX,EAA6B,CAA7B,CAAiC0B,UAAU,CAACxB,cAAX,CAA4BwB,UAAU,CAAC1B,cAAxE,CAAyF,CAA9G,CAEA,GAAMyC,CAAAA,qBAAqB,CAAGf,UAAU,CAACxB,cAAX,EAA6BsC,YAA7B,CAA4CH,OAAO,CAAGC,IAAI,CAACC,IAAL,CAAUC,YAAV,CAAtD,CAAgF,CAA9G,CACA,GAAME,CAAAA,qBAAqB,CACzBC,MAAM,CAACjB,UAAU,CAACxB,cAAZ,CAAN,EAAqCsC,YAArC,CAAoDH,OAAO,CAAGC,IAAI,CAACC,IAAL,CAAUC,YAAV,CAA9D,CAAwF,CAD1F,CAEA,GAAMI,CAAAA,WAAW,CACfH,qBAAqB,CAAGf,UAAU,CAAC1B,cAAnC,CAAoD0C,qBAAqB,CAAGhB,UAAU,CAACxB,cADzF,CAGA,GAAM2C,CAAAA,sBAAsB,CAAGV,gBAAgB,CAAGM,qBAAlD,CACA,GAAMK,CAAAA,sBAAsB,CAAGV,gBAAgB,CAAGM,qBAAlD,CACA,GAAMK,CAAAA,mBAAmB,CACvBF,sBAAsB,CAAGnB,UAAU,CAAC1B,cAApC,CAAqD8C,sBAAsB,CAAGpB,UAAU,CAACxB,cAD3F,CAGA;AACA,GAAM8C,CAAAA,YAAY,CAAGjB,gBAAgB,CAAGN,UAAU,CAACzB,cAA9B,CAA+CiC,gBAAgB,CAAGR,UAAU,CAACvB,cAAlG,CACA,GAAM+C,CAAAA,YAAY,CAAGlB,gBAAgB,CAAGL,UAAU,CAAC1B,cAA9B,CAA+CiC,gBAAgB,CAAGP,UAAU,CAACxB,cAAlG,CAEA,GAAMgD,CAAAA,YAAY,CAAGN,WAAW,CAAGK,YAAnC,CACA,GAAME,CAAAA,cAAc,CAAGJ,mBAAmB,CAAGG,YAA7C,CAEA;AACA,GAAME,CAAAA,UAAU,CAAGzB,WAAW,CAAGF,UAAU,CAAC4B,UAA5C,CACA,GAAMC,CAAAA,UAAU,CAAGxB,WAAW,CAAGJ,UAAU,CAAC2B,UAA5C,CAEA,MAAO,CACLE,WAAW,CAAEN,YAAY,CAAGD,YADvB,CAELQ,SAAS,CAAEF,UAAU,CAAGF,UAFnB,CAGLK,aAAa,CAAEN,cAHV,CAILO,OAAO,CAAER,YAJJ,CAKLS,IAAI,CAAEZ,mBALD,CAAP,CAOD,CAED;AACA;AACA;AACA;AACA;AACA;AACA,GACA,eAAsBa,CAAAA,wBAAtB,0EAsFA;AACA;AACA;AACA;AACA;AACA,G,uHA3FO,kBAAwCC,kBAAxC,CAA4DC,eAA5D,CAA6EC,aAA7E,CAA4FC,eAA5F,qQAEAF,eAAe,CAACG,kBAFhB,2DAGI,EAHJ,SAKDC,QALC,CAKkB5B,IAAI,CAAC6B,KAAL,CAAWN,kBAAkB,CAAG,KAAhC,CALlB,CAKyD;AACxDO,eAND,CAM2B9B,IAAI,CAAC6B,KAAL,CAAW9E,KAAK,CAACgF,GAAN,GAAYC,IAAZ,GAAqB,KAAhC,CAN3B,CAOCC,eAPD,CAOmBR,aAAa,CAACS,IAAd,CAAmB,SAACC,CAAD,CAAIC,CAAJ,CAAU,CACnD,MAAOC,CAAAA,QAAQ,CAACF,CAAC,CAAC9E,SAAH,CAAR,CAAwBgF,QAAQ,CAACD,CAAC,CAAC/E,SAAH,CAAhC,CAAgD,CAAhD,CAAoD,CAAC,CAA5D,CACD,CAFuB,CAPnB,CAUL,GAAI4E,eAAe,CAAC,CAAD,CAAf,CAAmB5E,SAAnB,CAA+BkE,kBAAnC,CAAuD,CACrDK,QAAQ,CAAG5B,IAAI,CAAC6B,KAAL,CAAWI,eAAe,CAAC,CAAD,CAAf,CAAmB5E,SAAnB,CAA+B,KAA1C,CAAX,CACD,CAEKiF,aAdD,CAciB,EAdjB,CAeL,MAAOV,QAAQ,CAAGE,eAAlB,CAAmC,CACjC;AACA,GAAIF,QAAQ,CAAG,KAAX,EAAoBS,QAAQ,CAACb,eAAe,CAACG,kBAAjB,CAAhC,CAAsE,CACpEW,aAAa,CAACC,IAAd,CAAmBX,QAAQ,CAAG,KAA9B,EACD,CACDA,QAAQ,CAAGA,QAAQ,CAAG,CAAtB,CACD,CArBI,wBAuBqB5E,CAAAA,qBAAqB,CAACwE,eAAe,CAAC/D,EAAjB,CAAqB6E,aAArB,CAvB1C,SAuBCE,WAvBD,gBAwBCC,oBAxBD,CAwBwB,EAxBxB,CAyBLD,WAAW,OAAX,EAAAA,WAAW,SAAX,QAAAA,WAAW,CAAEE,GAAb,CAAiB,SAACC,KAAD,CAAW,CAC1BF,oBAAoB,CAACE,KAAK,CAACtF,SAAP,CAApB,CAAwCsF,KAAxC,CACD,CAFD,EAIA;AACIxD,UA9BC,CA8BYsC,aAAa,CAAC,CAAD,CA9BzB,CA+BCmB,gBA/BD,CA+BoB,EA/BpB,CAgCDC,OAhCC,CAgCS,CAhCT,CAkCL;AAlCK,qBAmCMvE,KAnCN,EAoCH;AACA,GAAMwE,CAAAA,YAAY,CAAGR,aAAa,CAAChE,KAAD,CAAlC,CACA,GAAMyE,CAAAA,gBAAgB,CAAGD,YAAY,CAAG,KAAxC,CAEA;AACA,GAAME,CAAAA,YAAY,CAAGvB,aAAa,CAACwB,MAAd,CAAqB,SAACC,QAAD,CAAc,CACtD,MAAOA,CAAAA,QAAQ,CAAC7F,SAAT,CAAqB0F,gBAArB,EAAyCG,QAAQ,CAAC7F,SAAT,CAAqByF,YAArE,CACD,CAFoB,CAArB,CAGA,IAAK,GAAIK,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGH,YAAY,CAACI,MAAjC,CAAyCD,CAAC,EAA1C,CAA8C,CAC5C,GAAM/D,CAAAA,UAAU,CAAG4D,YAAY,CAACG,CAAD,CAA/B,CACA,GAAME,CAAAA,YAAY,CAAGnE,2BAA2B,CAACC,UAAD,CAAaC,UAAb,CAAhD,CACAyD,OAAO,CAAGA,OAAO,CAAGQ,YAAY,CAAChC,IAAjC,CACAlC,UAAU,CAAGC,UAAb,CACD,CAED;AACA,GAAIA,CAAAA,UAAU,CAAGqD,oBAAoB,CAACK,YAAY,CAAG,KAAhB,CAArC,CACA,GAAI,CAAC1D,UAAL,CAAiB,CACfA,UAAU,CAAG,CACX7B,IAAI,CAAEiE,eAAe,CAAC/D,EADX,CAEX6B,qBAAqB,CAAEH,UAAU,CAACG,qBAFvB,CAGXgE,WAAW,CAAE9B,eAAe,CAAC8B,WAHlB,CAIX5D,QAAQ,CAAE8B,eAAe,CAAC9B,QAJf,CAKXE,QAAQ,CAAE4B,eAAe,CAAC5B,QALf,CAMXmB,UAAU,CAAES,eAAe,CAACT,UANjB,CAOXrD,cAAc,CAAE8D,eAAe,CAAChE,MAAhB,CAAuB+F,UAAvB,CAAoC7B,eAPzC,CAQX9D,cAAc,CAAE4D,eAAe,CAAC7D,MAAhB,CAAuB4F,UAAvB,CAAoC7B,eARzC,CAAb,CAUD,CAED,GAAItC,UAAJ,CAAgB,CACdA,UAAU,CAACG,yBAAX,CAAuCH,UAAU,CAACkE,WAAlD,CACAlE,UAAU,CAACE,qBAAX,CAAmCH,UAAU,CAACG,qBAA9C,CACA,GAAMkE,CAAAA,qBAAqB,CACxB5E,UAAU,CAACQ,UAAU,CAACE,qBAAZ,CAAV,CAA+CV,UAAU,CAACQ,UAAU,CAACG,yBAAZ,CAA1D,CACAX,UAAU,CAACQ,UAAU,CAAC2B,UAAZ,CAFZ,CAGA,GAAMsC,CAAAA,aAAY,CAAGnE,2BAA2B,CAACC,UAAD,CAAaC,UAAb,CAAhD,CACA,GAAMqE,CAAAA,SAAS,CAAGZ,OAAO,CAAGQ,aAAY,CAAChC,IAAzC,CAEAuB,gBAAgB,CAACL,IAAjB,CAAsB,CACpBmB,IAAI,CAAEZ,YADc,CAEpBa,QAAQ,CAAEH,qBAFU,CAGpBnC,IAAI,CAAEoC,SAHc,CAAtB,EAKD,CAhFE,EAmCL,IAAWnF,KAAX,GAAoBgE,CAAAA,aAApB,CAAmC,OAAxBhE,KAAwB,EA8ClC,CAjFI,iCAmFEsE,gBAnFF,2D,2DA4FP,eAAsBgB,CAAAA,kBAAtB,qE,2GAAO,kBAAkC9F,IAAlC,CAAgDP,IAAhD,CAAsDsG,QAAtD,CAAwEC,SAAxE,uQAEmBjG,CAAAA,0BAA0B,CAACC,IAAD,CAAOP,IAAI,CAACE,EAAZ,CAF7C,QAECsG,SAFD,gBAGDC,UAHC,CAGY,CAHZ,CAID9C,SAJC,CAIW,CAJX,CAKDC,aALC,CAKe,CALf,CAMDE,IANC,CAMM,CANN,CAQLyC,SAAS,CAAGA,SAAS,CAACb,MAAV,CAAiB,SAACgB,KAAD,CAAW,CACtC,MAAOA,CAAAA,KAAK,CAAC1G,IAAN,CAAWE,EAAX,GAAkBF,IAAI,CAACE,EAA9B,CACD,CAFW,CAAZ,CAIA;AACMyG,eAbD,CAa6B,CAChC3G,IAAI,CAAJA,IADgC,CAEhC+B,qBAAqB,aAAEwE,SAAS,CAACA,SAAS,CAACV,MAAV,CAAmB,CAApB,CAAX,qCAAE,WAAiC9D,qBAFxB,CAGhCC,yBAAyB,CAAEhC,IAAI,CAAC+F,WAHA,CAIhC5D,QAAQ,CAAEnC,IAAI,CAACmC,QAJiB,CAKhCE,QAAQ,CAAErC,IAAI,CAACqC,QALiB,CAMhCmB,UAAU,CAAExD,IAAI,CAACwD,UANe,CAOhCrD,cAAc,CAAEH,IAAI,CAACC,MAAL,CAAY+F,UAAZ,CAAyBM,QAPT,CAQhCjG,cAAc,CAAEL,IAAI,CAACI,MAAL,CAAY4F,UAAZ,CAAyBM,QART,CAb7B,CAwBL,IAAWvF,KAAX,GAAoBwF,CAAAA,SAApB,CAA+B,CAC7B;AACM3E,WAFuB,CAEV2E,SAAS,CAACxF,KAAD,CAFC,CAGvBc,UAHuB,CAGViD,QAAQ,CAAC/D,KAAD,CAAR,GAAoBwF,SAAS,CAACV,MAAV,CAAmB,CAAvC,CAA2Cc,eAA3C,CAA6DJ,SAAS,CAACzB,QAAQ,CAAC/D,KAAD,CAAR,CAAkB,CAAnB,CAH5D,CAKvBD,OALuB,CAKba,2BAA2B,CAACC,WAAD,CAAaC,UAAb,CALd,CAM7B4E,UAAU,CAAGA,UAAU,CAAG3F,OAAO,CAAC4C,WAAlC,CACAC,SAAS,CAAGA,SAAS,CAAG7C,OAAO,CAAC6C,SAAhC,CACAC,aAAa,CAAGA,aAAa,CAAG9C,OAAO,CAAC8C,aAAxC,CACAE,IAAI,CAAGA,IAAI,CAAGhD,OAAO,CAACgD,IAAtB,CACD,CAlCI,iCAoCE,CACL0C,SAAS,CAATA,SADK,CAELI,GAAG,CAAE,CACHC,MAAM,CAAElD,SADL,CAFA,CAKLmD,OAAO,CAAE,CACPD,MAAM,CAAEjD,aADD,CALJ,CAQLE,IAAI,CAAE,CACJiD,GAAG,CAAEjD,IADD,CARD,CApCF,2D","sourcesContent":["/* eslint-disable */\nimport { USER_MINTS_BUNRS_PER_PAIR } from '../apollo/queries'\nimport { client } from '../apollo/client'\nimport dayjs from 'dayjs'\nimport { getShareValueOverTime } from '.'\n\nexport const priceOverrides = [\n  '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // USDC\n  '0x6b175474e89094c44da98b954eedeac495271d0f', // DAI\n]\n\ninterface ReturnMetrics {\n  hodleReturn: number // difference in asset values t0 -> t1 with t0 deposit amounts\n  netReturn: number // net return from t0 -> t1\n  uniswapReturn: number // netReturn - hodlReturn\n  impLoss: number\n  fees: number\n}\n\n// used to calculate returns within a given window bounded by two positions\ninterface Position {\n  pair: any\n  liquidityTokenBalance: number\n  liquidityTokenTotalSupply: number\n  reserve0: number\n  reserve1: number\n  reserveUSD: number\n  token0PriceUSD: number\n  token1PriceUSD: number\n}\n\nconst PRICE_DISCOVERY_START_TIMESTAMP = 1589747086\n\nfunction formatPricesForEarlyTimestamps(position): Position {\n  if (position.timestamp < PRICE_DISCOVERY_START_TIMESTAMP) {\n    if (priceOverrides.includes(position?.pair?.token0.id)) {\n      position.token0PriceUSD = 1\n    }\n    if (priceOverrides.includes(position?.pair?.token1.id)) {\n      position.token1PriceUSD = 1\n    }\n    // WETH price\n    if (position.pair?.token0.id === '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2') {\n      position.token0PriceUSD = 203\n    }\n    if (position.pair?.token1.id === '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2') {\n      position.token1PriceUSD = 203\n    }\n  }\n  return position\n}\n\nasync function getPrincipalForUserPerPair(user: string, pairAddress: string) {\n  let usd = 0\n  let amount0 = 0\n  let amount1 = 0\n  // get all minst and burns to get principal amounts\n  const results = await client.query({\n    query: USER_MINTS_BUNRS_PER_PAIR,\n    variables: {\n      user,\n      pair: pairAddress,\n    },\n  })\n  for (const index in results.data.mints) {\n    const mint = results.data.mints[index]\n    const mintToken0 = mint.pair.token0.id\n    const mintToken1 = mint.pair.token1.id\n\n    // if trackign before prices were discovered (pre-launch days), hardcode stablecoins\n    if (priceOverrides.includes(mintToken0) && mint.timestamp < PRICE_DISCOVERY_START_TIMESTAMP) {\n      usd += parseFloat(mint.amount0) * 2\n    } else if (priceOverrides.includes(mintToken1) && mint.timestamp < PRICE_DISCOVERY_START_TIMESTAMP) {\n      usd += parseFloat(mint.amount1) * 2\n    } else {\n      usd += parseFloat(mint.amountUSD)\n    }\n    amount0 += amount0 + parseFloat(mint.amount0)\n    amount1 += amount1 + parseFloat(mint.amount1)\n  }\n\n  for (const index in results.data.burns) {\n    const burn = results.data.burns[index]\n    const burnToken0 = burn.pair.token0.id\n    const burnToken1 = burn.pair.token1.id\n\n    // if trackign before prices were discovered (pre-launch days), hardcode stablecoins\n    if (priceOverrides.includes(burnToken0) && burn.timestamp < PRICE_DISCOVERY_START_TIMESTAMP) {\n      usd += parseFloat(burn.amount0) * 2\n    } else if (priceOverrides.includes(burnToken1) && burn.timestamp < PRICE_DISCOVERY_START_TIMESTAMP) {\n      usd += parseFloat(burn.amount1) * 2\n    } else {\n      usd -= parseFloat(results.data.burns[index].amountUSD)\n    }\n\n    amount0 -= parseFloat(results.data.burns[index].amount0)\n    amount1 -= parseFloat(results.data.burns[index].amount1)\n  }\n\n  return { usd, amount0, amount1 }\n}\n\n/**\n * Core algorithm for calculating retursn within one time window.\n * @param positionT0 // users liquidity info and token rates at beginning of window\n * @param positionT1 // '' at the end of the window\n */\nexport function getMetricsForPositionWindow(positionT0: Position, positionT1: Position): ReturnMetrics {\n  positionT0 = formatPricesForEarlyTimestamps(positionT0)\n  positionT1 = formatPricesForEarlyTimestamps(positionT1)\n\n  // calculate ownership at ends of window, for end of window we need original LP token balance / new total supply\n  const t0Ownership = positionT0.liquidityTokenBalance / positionT0.liquidityTokenTotalSupply\n  const t1Ownership = positionT0.liquidityTokenBalance / positionT1.liquidityTokenTotalSupply\n\n  // get starting amounts of token0 and token1 deposited by LP\n  const token0_amount_t0 = t0Ownership * positionT0.reserve0\n  const token1_amount_t0 = t0Ownership * positionT0.reserve1\n\n  // get current token values\n  const token0_amount_t1 = t1Ownership * positionT1.reserve0\n  const token1_amount_t1 = t1Ownership * positionT1.reserve1\n\n  // calculate squares to find imp loss and fee differences\n  const sqrK_t0 = Math.sqrt(token0_amount_t0 * token1_amount_t0)\n  // eslint-disable-next-line eqeqeq\n  const priceRatioT1 = positionT1.token0PriceUSD != 0 ? positionT1.token1PriceUSD / positionT1.token0PriceUSD : 0\n\n  const token0_amount_no_fees = positionT1.token1PriceUSD && priceRatioT1 ? sqrK_t0 * Math.sqrt(priceRatioT1) : 0\n  const token1_amount_no_fees =\n    Number(positionT1.token1PriceUSD) && priceRatioT1 ? sqrK_t0 / Math.sqrt(priceRatioT1) : 0\n  const no_fees_usd =\n    token0_amount_no_fees * positionT1.token0PriceUSD + token1_amount_no_fees * positionT1.token1PriceUSD\n\n  const difference_fees_token0 = token0_amount_t1 - token0_amount_no_fees\n  const difference_fees_token1 = token1_amount_t1 - token1_amount_no_fees\n  const difference_fees_usd =\n    difference_fees_token0 * positionT1.token0PriceUSD + difference_fees_token1 * positionT1.token1PriceUSD\n\n  // calculate USD value at t0 and t1 using initial token deposit amounts for asset return\n  const assetValueT0 = token0_amount_t0 * positionT0.token0PriceUSD + token1_amount_t0 * positionT0.token1PriceUSD\n  const assetValueT1 = token0_amount_t0 * positionT1.token0PriceUSD + token1_amount_t0 * positionT1.token1PriceUSD\n\n  const imp_loss_usd = no_fees_usd - assetValueT1\n  const uniswap_return = difference_fees_usd + imp_loss_usd\n\n  // get net value change for combined data\n  const netValueT0 = t0Ownership * positionT0.reserveUSD\n  const netValueT1 = t1Ownership * positionT1.reserveUSD\n\n  return {\n    hodleReturn: assetValueT1 - assetValueT0,\n    netReturn: netValueT1 - netValueT0,\n    uniswapReturn: uniswap_return,\n    impLoss: imp_loss_usd,\n    fees: difference_fees_usd,\n  }\n}\n\n/**\n * formats data for historical chart for an LPs position in 1 pair over time\n * @param startDateTimestamp // day to start tracking at\n * @param currentPairData // current stat of the pair\n * @param pairSnapshots // history of entries and exits for lp on this pair\n * @param currentETHPrice // current price of eth used for usd conversions\n */\nexport async function getHistoricalPairReturns(startDateTimestamp, currentPairData, pairSnapshots, currentETHPrice) {\n  // catch case where data not puplated yet\n  if (!currentPairData.createdAtTimestamp) {\n    return []\n  }\n  let dayIndex: number = Math.round(startDateTimestamp / 86400) // get unique day bucket unix\n  const currentDayIndex: number = Math.round(dayjs.utc().unix() / 86400)\n  const sortedPositions = pairSnapshots.sort((a, b) => {\n    return parseInt(a.timestamp) > parseInt(b.timestamp) ? 1 : -1\n  })\n  if (sortedPositions[0].timestamp > startDateTimestamp) {\n    dayIndex = Math.round(sortedPositions[0].timestamp / 86400)\n  }\n\n  const dayTimestamps = []\n  while (dayIndex < currentDayIndex) {\n    // only account for days where this pair existed\n    if (dayIndex * 86400 >= parseInt(currentPairData.createdAtTimestamp)) {\n      dayTimestamps.push(dayIndex * 86400)\n    }\n    dayIndex = dayIndex + 1\n  }\n\n  const shareValues = await getShareValueOverTime(currentPairData.id, dayTimestamps)\n  const shareValuesFormatted = {}\n  shareValues?.map((share) => {\n    shareValuesFormatted[share.timestamp] = share\n  })\n\n  // set the default position and data\n  let positionT0 = pairSnapshots[0]\n  const formattedHistory = []\n  let netFees = 0\n\n  // keep track of up to date metrics as we parse each day\n  for (const index in dayTimestamps) {\n    // get the bounds on the day\n    const dayTimestamp = dayTimestamps[index]\n    const timestampCeiling = dayTimestamp + 86400\n\n    // for each change in position value that day, create a window and update\n    const dailyChanges = pairSnapshots.filter((snapshot) => {\n      return snapshot.timestamp < timestampCeiling && snapshot.timestamp > dayTimestamp\n    })\n    for (let i = 0; i < dailyChanges.length; i++) {\n      const positionT1 = dailyChanges[i]\n      const localReturns = getMetricsForPositionWindow(positionT0, positionT1)\n      netFees = netFees + localReturns.fees\n      positionT0 = positionT1\n    }\n\n    // now treat the end of the day as a hypothetical position\n    let positionT1 = shareValuesFormatted[dayTimestamp + 86400]\n    if (!positionT1) {\n      positionT1 = {\n        pair: currentPairData.id,\n        liquidityTokenBalance: positionT0.liquidityTokenBalance,\n        totalSupply: currentPairData.totalSupply,\n        reserve0: currentPairData.reserve0,\n        reserve1: currentPairData.reserve1,\n        reserveUSD: currentPairData.reserveUSD,\n        token0PriceUSD: currentPairData.token0.derivedETH * currentETHPrice,\n        token1PriceUSD: currentPairData.token1.derivedETH * currentETHPrice,\n      }\n    }\n\n    if (positionT1) {\n      positionT1.liquidityTokenTotalSupply = positionT1.totalSupply\n      positionT1.liquidityTokenBalance = positionT0.liquidityTokenBalance\n      const currentLiquidityValue =\n        (parseFloat(positionT1.liquidityTokenBalance) / parseFloat(positionT1.liquidityTokenTotalSupply)) *\n        parseFloat(positionT1.reserveUSD)\n      const localReturns = getMetricsForPositionWindow(positionT0, positionT1)\n      const localFees = netFees + localReturns.fees\n\n      formattedHistory.push({\n        date: dayTimestamp,\n        usdValue: currentLiquidityValue,\n        fees: localFees,\n      })\n    }\n  }\n\n  return formattedHistory\n}\n\n/**\n * For a given pair and user, get the return metrics\n * @param user\n * @param pair\n * @param ethPrice\n */\nexport async function getLPReturnsOnPair(user: string, pair, ethPrice: number, snapshots) {\n  // initialize values\n  const principal = await getPrincipalForUserPerPair(user, pair.id)\n  let hodlReturn = 0\n  let netReturn = 0\n  let uniswapReturn = 0\n  let fees = 0\n\n  snapshots = snapshots.filter((entry) => {\n    return entry.pair.id === pair.id\n  })\n\n  // get data about the current position\n  const currentPosition: Position = {\n    pair,\n    liquidityTokenBalance: snapshots[snapshots.length - 1]?.liquidityTokenBalance,\n    liquidityTokenTotalSupply: pair.totalSupply,\n    reserve0: pair.reserve0,\n    reserve1: pair.reserve1,\n    reserveUSD: pair.reserveUSD,\n    token0PriceUSD: pair.token0.derivedETH * ethPrice,\n    token1PriceUSD: pair.token1.derivedETH * ethPrice,\n  }\n\n  for (const index in snapshots) {\n    // get positions at both bounds of the window\n    const positionT0 = snapshots[index]\n    const positionT1 = parseInt(index) === snapshots.length - 1 ? currentPosition : snapshots[parseInt(index) + 1]\n\n    const results = getMetricsForPositionWindow(positionT0, positionT1)\n    hodlReturn = hodlReturn + results.hodleReturn\n    netReturn = netReturn + results.netReturn\n    uniswapReturn = uniswapReturn + results.uniswapReturn\n    fees = fees + results.fees\n  }\n\n  return {\n    principal,\n    net: {\n      return: netReturn,\n    },\n    uniswap: {\n      return: uniswapReturn,\n    },\n    fees: {\n      sum: fees,\n    },\n  }\n}\n"]},"metadata":{},"sourceType":"module"}