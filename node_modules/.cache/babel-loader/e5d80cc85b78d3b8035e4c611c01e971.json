{"ast":null,"code":"/* eslint-disable */\nimport { USER_MINTS_BUNRS_PER_PAIR } from '../apollo/queries';\nimport { client } from '../apollo/client';\nimport dayjs from 'dayjs';\nimport { getShareValueOverTime } from '.';\nexport const priceOverrides = ['0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // USDC\n'0x6b175474e89094c44da98b954eedeac495271d0f' // DAI\n];\nconst PRICE_DISCOVERY_START_TIMESTAMP = 1589747086;\n\nfunction formatPricesForEarlyTimestamps(position) {\n  if (position.timestamp < PRICE_DISCOVERY_START_TIMESTAMP) {\n    var _position$pair, _position$pair2, _position$pair3, _position$pair4;\n\n    if (priceOverrides.includes(position === null || position === void 0 ? void 0 : (_position$pair = position.pair) === null || _position$pair === void 0 ? void 0 : _position$pair.token0.id)) {\n      position.token0PriceUSD = 1;\n    }\n\n    if (priceOverrides.includes(position === null || position === void 0 ? void 0 : (_position$pair2 = position.pair) === null || _position$pair2 === void 0 ? void 0 : _position$pair2.token1.id)) {\n      position.token1PriceUSD = 1;\n    } // WETH price\n\n\n    if (((_position$pair3 = position.pair) === null || _position$pair3 === void 0 ? void 0 : _position$pair3.token0.id) === '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2') {\n      position.token0PriceUSD = 203;\n    }\n\n    if (((_position$pair4 = position.pair) === null || _position$pair4 === void 0 ? void 0 : _position$pair4.token1.id) === '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2') {\n      position.token1PriceUSD = 203;\n    }\n  }\n\n  return position;\n}\n\nasync function getPrincipalForUserPerPair(user, pairAddress) {\n  let usd = 0;\n  let amount0 = 0;\n  let amount1 = 0; // get all minst and burns to get principal amounts\n\n  const results = await client.query({\n    query: USER_MINTS_BUNRS_PER_PAIR,\n    variables: {\n      user,\n      pair: pairAddress\n    }\n  });\n\n  for (const index in results.data.mints) {\n    const mint = results.data.mints[index];\n    const mintToken0 = mint.pair.token0.id;\n    const mintToken1 = mint.pair.token1.id; // if trackign before prices were discovered (pre-launch days), hardcode stablecoins\n\n    if (priceOverrides.includes(mintToken0) && mint.timestamp < PRICE_DISCOVERY_START_TIMESTAMP) {\n      usd += parseFloat(mint.amount0) * 2;\n    } else if (priceOverrides.includes(mintToken1) && mint.timestamp < PRICE_DISCOVERY_START_TIMESTAMP) {\n      usd += parseFloat(mint.amount1) * 2;\n    } else {\n      usd += parseFloat(mint.amountUSD);\n    }\n\n    amount0 += amount0 + parseFloat(mint.amount0);\n    amount1 += amount1 + parseFloat(mint.amount1);\n  }\n\n  for (const index in results.data.burns) {\n    const burn = results.data.burns[index];\n    const burnToken0 = burn.pair.token0.id;\n    const burnToken1 = burn.pair.token1.id; // if trackign before prices were discovered (pre-launch days), hardcode stablecoins\n\n    if (priceOverrides.includes(burnToken0) && burn.timestamp < PRICE_DISCOVERY_START_TIMESTAMP) {\n      usd += parseFloat(burn.amount0) * 2;\n    } else if (priceOverrides.includes(burnToken1) && burn.timestamp < PRICE_DISCOVERY_START_TIMESTAMP) {\n      usd += parseFloat(burn.amount1) * 2;\n    } else {\n      usd -= parseFloat(results.data.burns[index].amountUSD);\n    }\n\n    amount0 -= parseFloat(results.data.burns[index].amount0);\n    amount1 -= parseFloat(results.data.burns[index].amount1);\n  }\n\n  return {\n    usd,\n    amount0,\n    amount1\n  };\n}\n/**\n * Core algorithm for calculating retursn within one time window.\n * @param positionT0 // users liquidity info and token rates at beginning of window\n * @param positionT1 // '' at the end of the window\n */\n\n\nexport function getMetricsForPositionWindow(positionT0, positionT1) {\n  positionT0 = formatPricesForEarlyTimestamps(positionT0);\n  positionT1 = formatPricesForEarlyTimestamps(positionT1); // calculate ownership at ends of window, for end of window we need original LP token balance / new total supply\n\n  const t0Ownership = positionT0.liquidityTokenBalance / positionT0.liquidityTokenTotalSupply;\n  const t1Ownership = positionT0.liquidityTokenBalance / positionT1.liquidityTokenTotalSupply; // get starting amounts of token0 and token1 deposited by LP\n\n  const token0_amount_t0 = t0Ownership * positionT0.reserve0;\n  const token1_amount_t0 = t0Ownership * positionT0.reserve1; // get current token values\n\n  const token0_amount_t1 = t1Ownership * positionT1.reserve0;\n  const token1_amount_t1 = t1Ownership * positionT1.reserve1; // calculate squares to find imp loss and fee differences\n\n  const sqrK_t0 = Math.sqrt(token0_amount_t0 * token1_amount_t0); // eslint-disable-next-line eqeqeq\n\n  const priceRatioT1 = positionT1.token0PriceUSD != 0 ? positionT1.token1PriceUSD / positionT1.token0PriceUSD : 0;\n  const token0_amount_no_fees = positionT1.token1PriceUSD && priceRatioT1 ? sqrK_t0 * Math.sqrt(priceRatioT1) : 0;\n  const token1_amount_no_fees = Number(positionT1.token1PriceUSD) && priceRatioT1 ? sqrK_t0 / Math.sqrt(priceRatioT1) : 0;\n  const no_fees_usd = token0_amount_no_fees * positionT1.token0PriceUSD + token1_amount_no_fees * positionT1.token1PriceUSD;\n  const difference_fees_token0 = token0_amount_t1 - token0_amount_no_fees;\n  const difference_fees_token1 = token1_amount_t1 - token1_amount_no_fees;\n  const difference_fees_usd = difference_fees_token0 * positionT1.token0PriceUSD + difference_fees_token1 * positionT1.token1PriceUSD; // calculate USD value at t0 and t1 using initial token deposit amounts for asset return\n\n  const assetValueT0 = token0_amount_t0 * positionT0.token0PriceUSD + token1_amount_t0 * positionT0.token1PriceUSD;\n  const assetValueT1 = token0_amount_t0 * positionT1.token0PriceUSD + token1_amount_t0 * positionT1.token1PriceUSD;\n  const imp_loss_usd = no_fees_usd - assetValueT1;\n  const uniswap_return = difference_fees_usd + imp_loss_usd; // get net value change for combined data\n\n  const netValueT0 = t0Ownership * positionT0.reserveUSD;\n  const netValueT1 = t1Ownership * positionT1.reserveUSD;\n  return {\n    hodleReturn: assetValueT1 - assetValueT0,\n    netReturn: netValueT1 - netValueT0,\n    uniswapReturn: uniswap_return,\n    impLoss: imp_loss_usd,\n    fees: difference_fees_usd\n  };\n}\n/**\n * formats data for historical chart for an LPs position in 1 pair over time\n * @param startDateTimestamp // day to start tracking at\n * @param currentPairData // current stat of the pair\n * @param pairSnapshots // history of entries and exits for lp on this pair\n * @param currentETHPrice // current price of eth used for usd conversions\n */\n\nexport async function getHistoricalPairReturns(startDateTimestamp, currentPairData, pairSnapshots, currentETHPrice) {\n  // catch case where data not puplated yet\n  if (!currentPairData.createdAtTimestamp) {\n    return [];\n  }\n\n  let dayIndex = Math.round(startDateTimestamp / 86400); // get unique day bucket unix\n\n  const currentDayIndex = Math.round(dayjs.utc().unix() / 86400);\n  const sortedPositions = pairSnapshots.sort((a, b) => {\n    return parseInt(a.timestamp) > parseInt(b.timestamp) ? 1 : -1;\n  });\n\n  if (sortedPositions[0].timestamp > startDateTimestamp) {\n    dayIndex = Math.round(sortedPositions[0].timestamp / 86400);\n  }\n\n  const dayTimestamps = [];\n\n  while (dayIndex < currentDayIndex) {\n    // only account for days where this pair existed\n    if (dayIndex * 86400 >= parseInt(currentPairData.createdAtTimestamp)) {\n      dayTimestamps.push(dayIndex * 86400);\n    }\n\n    dayIndex = dayIndex + 1;\n  }\n\n  const shareValues = await getShareValueOverTime(currentPairData.id, dayTimestamps);\n  const shareValuesFormatted = {};\n  shareValues === null || shareValues === void 0 ? void 0 : shareValues.map(share => {\n    shareValuesFormatted[share.timestamp] = share;\n  }); // set the default position and data\n\n  let positionT0 = pairSnapshots[0];\n  const formattedHistory = [];\n  let netFees = 0; // keep track of up to date metrics as we parse each day\n\n  for (const index in dayTimestamps) {\n    // get the bounds on the day\n    const dayTimestamp = dayTimestamps[index];\n    const timestampCeiling = dayTimestamp + 86400; // for each change in position value that day, create a window and update\n\n    const dailyChanges = pairSnapshots.filter(snapshot => {\n      return snapshot.timestamp < timestampCeiling && snapshot.timestamp > dayTimestamp;\n    });\n\n    for (let i = 0; i < dailyChanges.length; i++) {\n      const positionT1 = dailyChanges[i];\n      const localReturns = getMetricsForPositionWindow(positionT0, positionT1);\n      netFees = netFees + localReturns.fees;\n      positionT0 = positionT1;\n    } // now treat the end of the day as a hypothetical position\n\n\n    let positionT1 = shareValuesFormatted[dayTimestamp + 86400];\n\n    if (!positionT1) {\n      positionT1 = {\n        pair: currentPairData.id,\n        liquidityTokenBalance: positionT0.liquidityTokenBalance,\n        totalSupply: currentPairData.totalSupply,\n        reserve0: currentPairData.reserve0,\n        reserve1: currentPairData.reserve1,\n        reserveUSD: currentPairData.reserveUSD,\n        token0PriceUSD: currentPairData.token0.derivedETH * currentETHPrice,\n        token1PriceUSD: currentPairData.token1.derivedETH * currentETHPrice\n      };\n    }\n\n    if (positionT1) {\n      positionT1.liquidityTokenTotalSupply = positionT1.totalSupply;\n      positionT1.liquidityTokenBalance = positionT0.liquidityTokenBalance;\n      const currentLiquidityValue = parseFloat(positionT1.liquidityTokenBalance) / parseFloat(positionT1.liquidityTokenTotalSupply) * parseFloat(positionT1.reserveUSD);\n      const localReturns = getMetricsForPositionWindow(positionT0, positionT1);\n      const localFees = netFees + localReturns.fees;\n      formattedHistory.push({\n        date: dayTimestamp,\n        usdValue: currentLiquidityValue,\n        fees: localFees\n      });\n    }\n  }\n\n  return formattedHistory;\n}\n/**\n * For a given pair and user, get the return metrics\n * @param user\n * @param pair\n * @param ethPrice\n */\n\nexport async function getLPReturnsOnPair(user, pair, ethPrice, snapshots) {\n  var _snapshots;\n\n  // initialize values\n  const principal = await getPrincipalForUserPerPair(user, pair.id);\n  let hodlReturn = 0;\n  let netReturn = 0;\n  let uniswapReturn = 0;\n  let fees = 0;\n  snapshots = snapshots.filter(entry => {\n    return entry.pair.id === pair.id;\n  }); // get data about the current position\n\n  const currentPosition = {\n    pair,\n    liquidityTokenBalance: (_snapshots = snapshots[snapshots.length - 1]) === null || _snapshots === void 0 ? void 0 : _snapshots.liquidityTokenBalance,\n    liquidityTokenTotalSupply: pair.totalSupply,\n    reserve0: pair.reserve0,\n    reserve1: pair.reserve1,\n    reserveUSD: pair.reserveUSD,\n    token0PriceUSD: pair.token0.derivedETH * ethPrice,\n    token1PriceUSD: pair.token1.derivedETH * ethPrice\n  };\n\n  for (const index in snapshots) {\n    // get positions at both bounds of the window\n    const positionT0 = snapshots[index];\n    const positionT1 = parseInt(index) === snapshots.length - 1 ? currentPosition : snapshots[parseInt(index) + 1];\n    const results = getMetricsForPositionWindow(positionT0, positionT1);\n    hodlReturn = hodlReturn + results.hodleReturn;\n    netReturn = netReturn + results.netReturn;\n    uniswapReturn = uniswapReturn + results.uniswapReturn;\n    fees = fees + results.fees;\n  }\n\n  return {\n    principal,\n    net: {\n      return: netReturn\n    },\n    uniswap: {\n      return: uniswapReturn\n    },\n    fees: {\n      sum: fees\n    }\n  };\n}","map":{"version":3,"sources":["/Users/macbook/Desktop/juiceswap/juiceswap-docs/src/utils/returns.ts"],"names":["USER_MINTS_BUNRS_PER_PAIR","client","dayjs","getShareValueOverTime","priceOverrides","PRICE_DISCOVERY_START_TIMESTAMP","formatPricesForEarlyTimestamps","position","timestamp","includes","pair","token0","id","token0PriceUSD","token1","token1PriceUSD","getPrincipalForUserPerPair","user","pairAddress","usd","amount0","amount1","results","query","variables","index","data","mints","mint","mintToken0","mintToken1","parseFloat","amountUSD","burns","burn","burnToken0","burnToken1","getMetricsForPositionWindow","positionT0","positionT1","t0Ownership","liquidityTokenBalance","liquidityTokenTotalSupply","t1Ownership","token0_amount_t0","reserve0","token1_amount_t0","reserve1","token0_amount_t1","token1_amount_t1","sqrK_t0","Math","sqrt","priceRatioT1","token0_amount_no_fees","token1_amount_no_fees","Number","no_fees_usd","difference_fees_token0","difference_fees_token1","difference_fees_usd","assetValueT0","assetValueT1","imp_loss_usd","uniswap_return","netValueT0","reserveUSD","netValueT1","hodleReturn","netReturn","uniswapReturn","impLoss","fees","getHistoricalPairReturns","startDateTimestamp","currentPairData","pairSnapshots","currentETHPrice","createdAtTimestamp","dayIndex","round","currentDayIndex","utc","unix","sortedPositions","sort","a","b","parseInt","dayTimestamps","push","shareValues","shareValuesFormatted","map","share","formattedHistory","netFees","dayTimestamp","timestampCeiling","dailyChanges","filter","snapshot","i","length","localReturns","totalSupply","derivedETH","currentLiquidityValue","localFees","date","usdValue","getLPReturnsOnPair","ethPrice","snapshots","principal","hodlReturn","entry","currentPosition","net","return","uniswap","sum"],"mappings":"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","sourcesContent":["/* eslint-disable */\nimport { USER_MINTS_BUNRS_PER_PAIR } from '../apollo/queries'\nimport { client } from '../apollo/client'\nimport dayjs from 'dayjs'\nimport { getShareValueOverTime } from '.'\n\nexport const priceOverrides = [\n  '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // USDC\n  '0x6b175474e89094c44da98b954eedeac495271d0f', // DAI\n]\n\ninterface ReturnMetrics {\n  hodleReturn: number // difference in asset values t0 -> t1 with t0 deposit amounts\n  netReturn: number // net return from t0 -> t1\n  uniswapReturn: number // netReturn - hodlReturn\n  impLoss: number\n  fees: number\n}\n\n// used to calculate returns within a given window bounded by two positions\ninterface Position {\n  pair: any\n  liquidityTokenBalance: number\n  liquidityTokenTotalSupply: number\n  reserve0: number\n  reserve1: number\n  reserveUSD: number\n  token0PriceUSD: number\n  token1PriceUSD: number\n}\n\nconst PRICE_DISCOVERY_START_TIMESTAMP = 1589747086\n\nfunction formatPricesForEarlyTimestamps(position): Position {\n  if (position.timestamp < PRICE_DISCOVERY_START_TIMESTAMP) {\n    if (priceOverrides.includes(position?.pair?.token0.id)) {\n      position.token0PriceUSD = 1\n    }\n    if (priceOverrides.includes(position?.pair?.token1.id)) {\n      position.token1PriceUSD = 1\n    }\n    // WETH price\n    if (position.pair?.token0.id === '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2') {\n      position.token0PriceUSD = 203\n    }\n    if (position.pair?.token1.id === '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2') {\n      position.token1PriceUSD = 203\n    }\n  }\n  return position\n}\n\nasync function getPrincipalForUserPerPair(user: string, pairAddress: string) {\n  let usd = 0\n  let amount0 = 0\n  let amount1 = 0\n  // get all minst and burns to get principal amounts\n  const results = await client.query({\n    query: USER_MINTS_BUNRS_PER_PAIR,\n    variables: {\n      user,\n      pair: pairAddress,\n    },\n  })\n  for (const index in results.data.mints) {\n    const mint = results.data.mints[index]\n    const mintToken0 = mint.pair.token0.id\n    const mintToken1 = mint.pair.token1.id\n\n    // if trackign before prices were discovered (pre-launch days), hardcode stablecoins\n    if (priceOverrides.includes(mintToken0) && mint.timestamp < PRICE_DISCOVERY_START_TIMESTAMP) {\n      usd += parseFloat(mint.amount0) * 2\n    } else if (priceOverrides.includes(mintToken1) && mint.timestamp < PRICE_DISCOVERY_START_TIMESTAMP) {\n      usd += parseFloat(mint.amount1) * 2\n    } else {\n      usd += parseFloat(mint.amountUSD)\n    }\n    amount0 += amount0 + parseFloat(mint.amount0)\n    amount1 += amount1 + parseFloat(mint.amount1)\n  }\n\n  for (const index in results.data.burns) {\n    const burn = results.data.burns[index]\n    const burnToken0 = burn.pair.token0.id\n    const burnToken1 = burn.pair.token1.id\n\n    // if trackign before prices were discovered (pre-launch days), hardcode stablecoins\n    if (priceOverrides.includes(burnToken0) && burn.timestamp < PRICE_DISCOVERY_START_TIMESTAMP) {\n      usd += parseFloat(burn.amount0) * 2\n    } else if (priceOverrides.includes(burnToken1) && burn.timestamp < PRICE_DISCOVERY_START_TIMESTAMP) {\n      usd += parseFloat(burn.amount1) * 2\n    } else {\n      usd -= parseFloat(results.data.burns[index].amountUSD)\n    }\n\n    amount0 -= parseFloat(results.data.burns[index].amount0)\n    amount1 -= parseFloat(results.data.burns[index].amount1)\n  }\n\n  return { usd, amount0, amount1 }\n}\n\n/**\n * Core algorithm for calculating retursn within one time window.\n * @param positionT0 // users liquidity info and token rates at beginning of window\n * @param positionT1 // '' at the end of the window\n */\nexport function getMetricsForPositionWindow(positionT0: Position, positionT1: Position): ReturnMetrics {\n  positionT0 = formatPricesForEarlyTimestamps(positionT0)\n  positionT1 = formatPricesForEarlyTimestamps(positionT1)\n\n  // calculate ownership at ends of window, for end of window we need original LP token balance / new total supply\n  const t0Ownership = positionT0.liquidityTokenBalance / positionT0.liquidityTokenTotalSupply\n  const t1Ownership = positionT0.liquidityTokenBalance / positionT1.liquidityTokenTotalSupply\n\n  // get starting amounts of token0 and token1 deposited by LP\n  const token0_amount_t0 = t0Ownership * positionT0.reserve0\n  const token1_amount_t0 = t0Ownership * positionT0.reserve1\n\n  // get current token values\n  const token0_amount_t1 = t1Ownership * positionT1.reserve0\n  const token1_amount_t1 = t1Ownership * positionT1.reserve1\n\n  // calculate squares to find imp loss and fee differences\n  const sqrK_t0 = Math.sqrt(token0_amount_t0 * token1_amount_t0)\n  // eslint-disable-next-line eqeqeq\n  const priceRatioT1 = positionT1.token0PriceUSD != 0 ? positionT1.token1PriceUSD / positionT1.token0PriceUSD : 0\n\n  const token0_amount_no_fees = positionT1.token1PriceUSD && priceRatioT1 ? sqrK_t0 * Math.sqrt(priceRatioT1) : 0\n  const token1_amount_no_fees =\n    Number(positionT1.token1PriceUSD) && priceRatioT1 ? sqrK_t0 / Math.sqrt(priceRatioT1) : 0\n  const no_fees_usd =\n    token0_amount_no_fees * positionT1.token0PriceUSD + token1_amount_no_fees * positionT1.token1PriceUSD\n\n  const difference_fees_token0 = token0_amount_t1 - token0_amount_no_fees\n  const difference_fees_token1 = token1_amount_t1 - token1_amount_no_fees\n  const difference_fees_usd =\n    difference_fees_token0 * positionT1.token0PriceUSD + difference_fees_token1 * positionT1.token1PriceUSD\n\n  // calculate USD value at t0 and t1 using initial token deposit amounts for asset return\n  const assetValueT0 = token0_amount_t0 * positionT0.token0PriceUSD + token1_amount_t0 * positionT0.token1PriceUSD\n  const assetValueT1 = token0_amount_t0 * positionT1.token0PriceUSD + token1_amount_t0 * positionT1.token1PriceUSD\n\n  const imp_loss_usd = no_fees_usd - assetValueT1\n  const uniswap_return = difference_fees_usd + imp_loss_usd\n\n  // get net value change for combined data\n  const netValueT0 = t0Ownership * positionT0.reserveUSD\n  const netValueT1 = t1Ownership * positionT1.reserveUSD\n\n  return {\n    hodleReturn: assetValueT1 - assetValueT0,\n    netReturn: netValueT1 - netValueT0,\n    uniswapReturn: uniswap_return,\n    impLoss: imp_loss_usd,\n    fees: difference_fees_usd,\n  }\n}\n\n/**\n * formats data for historical chart for an LPs position in 1 pair over time\n * @param startDateTimestamp // day to start tracking at\n * @param currentPairData // current stat of the pair\n * @param pairSnapshots // history of entries and exits for lp on this pair\n * @param currentETHPrice // current price of eth used for usd conversions\n */\nexport async function getHistoricalPairReturns(startDateTimestamp, currentPairData, pairSnapshots, currentETHPrice) {\n  // catch case where data not puplated yet\n  if (!currentPairData.createdAtTimestamp) {\n    return []\n  }\n  let dayIndex: number = Math.round(startDateTimestamp / 86400) // get unique day bucket unix\n  const currentDayIndex: number = Math.round(dayjs.utc().unix() / 86400)\n  const sortedPositions = pairSnapshots.sort((a, b) => {\n    return parseInt(a.timestamp) > parseInt(b.timestamp) ? 1 : -1\n  })\n  if (sortedPositions[0].timestamp > startDateTimestamp) {\n    dayIndex = Math.round(sortedPositions[0].timestamp / 86400)\n  }\n\n  const dayTimestamps = []\n  while (dayIndex < currentDayIndex) {\n    // only account for days where this pair existed\n    if (dayIndex * 86400 >= parseInt(currentPairData.createdAtTimestamp)) {\n      dayTimestamps.push(dayIndex * 86400)\n    }\n    dayIndex = dayIndex + 1\n  }\n\n  const shareValues = await getShareValueOverTime(currentPairData.id, dayTimestamps)\n  const shareValuesFormatted = {}\n  shareValues?.map((share) => {\n    shareValuesFormatted[share.timestamp] = share\n  })\n\n  // set the default position and data\n  let positionT0 = pairSnapshots[0]\n  const formattedHistory = []\n  let netFees = 0\n\n  // keep track of up to date metrics as we parse each day\n  for (const index in dayTimestamps) {\n    // get the bounds on the day\n    const dayTimestamp = dayTimestamps[index]\n    const timestampCeiling = dayTimestamp + 86400\n\n    // for each change in position value that day, create a window and update\n    const dailyChanges = pairSnapshots.filter((snapshot) => {\n      return snapshot.timestamp < timestampCeiling && snapshot.timestamp > dayTimestamp\n    })\n    for (let i = 0; i < dailyChanges.length; i++) {\n      const positionT1 = dailyChanges[i]\n      const localReturns = getMetricsForPositionWindow(positionT0, positionT1)\n      netFees = netFees + localReturns.fees\n      positionT0 = positionT1\n    }\n\n    // now treat the end of the day as a hypothetical position\n    let positionT1 = shareValuesFormatted[dayTimestamp + 86400]\n    if (!positionT1) {\n      positionT1 = {\n        pair: currentPairData.id,\n        liquidityTokenBalance: positionT0.liquidityTokenBalance,\n        totalSupply: currentPairData.totalSupply,\n        reserve0: currentPairData.reserve0,\n        reserve1: currentPairData.reserve1,\n        reserveUSD: currentPairData.reserveUSD,\n        token0PriceUSD: currentPairData.token0.derivedETH * currentETHPrice,\n        token1PriceUSD: currentPairData.token1.derivedETH * currentETHPrice,\n      }\n    }\n\n    if (positionT1) {\n      positionT1.liquidityTokenTotalSupply = positionT1.totalSupply\n      positionT1.liquidityTokenBalance = positionT0.liquidityTokenBalance\n      const currentLiquidityValue =\n        (parseFloat(positionT1.liquidityTokenBalance) / parseFloat(positionT1.liquidityTokenTotalSupply)) *\n        parseFloat(positionT1.reserveUSD)\n      const localReturns = getMetricsForPositionWindow(positionT0, positionT1)\n      const localFees = netFees + localReturns.fees\n\n      formattedHistory.push({\n        date: dayTimestamp,\n        usdValue: currentLiquidityValue,\n        fees: localFees,\n      })\n    }\n  }\n\n  return formattedHistory\n}\n\n/**\n * For a given pair and user, get the return metrics\n * @param user\n * @param pair\n * @param ethPrice\n */\nexport async function getLPReturnsOnPair(user: string, pair, ethPrice: number, snapshots) {\n  // initialize values\n  const principal = await getPrincipalForUserPerPair(user, pair.id)\n  let hodlReturn = 0\n  let netReturn = 0\n  let uniswapReturn = 0\n  let fees = 0\n\n  snapshots = snapshots.filter((entry) => {\n    return entry.pair.id === pair.id\n  })\n\n  // get data about the current position\n  const currentPosition: Position = {\n    pair,\n    liquidityTokenBalance: snapshots[snapshots.length - 1]?.liquidityTokenBalance,\n    liquidityTokenTotalSupply: pair.totalSupply,\n    reserve0: pair.reserve0,\n    reserve1: pair.reserve1,\n    reserveUSD: pair.reserveUSD,\n    token0PriceUSD: pair.token0.derivedETH * ethPrice,\n    token1PriceUSD: pair.token1.derivedETH * ethPrice,\n  }\n\n  for (const index in snapshots) {\n    // get positions at both bounds of the window\n    const positionT0 = snapshots[index]\n    const positionT1 = parseInt(index) === snapshots.length - 1 ? currentPosition : snapshots[parseInt(index) + 1]\n\n    const results = getMetricsForPositionWindow(positionT0, positionT1)\n    hodlReturn = hodlReturn + results.hodleReturn\n    netReturn = netReturn + results.netReturn\n    uniswapReturn = uniswapReturn + results.uniswapReturn\n    fees = fees + results.fees\n  }\n\n  return {\n    principal,\n    net: {\n      return: netReturn,\n    },\n    uniswap: {\n      return: uniswapReturn,\n    },\n    fees: {\n      sum: fees,\n    },\n  }\n}\n"]},"metadata":{},"sourceType":"module"}