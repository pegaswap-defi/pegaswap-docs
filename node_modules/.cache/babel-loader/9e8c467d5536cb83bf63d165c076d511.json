{"ast":null,"code":"var _jsxFileName = \"/Users/macbook/Desktop/Pega/pegaswap-docs/src/contexts/TokenData.js\";\nimport React, { createContext, useContext, useReducer, useMemo, useCallback, useEffect } from 'react';\nimport { client } from '../apollo/client';\nimport { TOKEN_DATA, FILTERED_TRANSACTIONS, TOKEN_CHART, TOKENS_CURRENT, TOKENS_DYNAMIC, PRICES_BY_BLOCK, PAIR_DATA } from '../apollo/queries';\nimport { useEthPrice } from './GlobalData';\nimport dayjs from 'dayjs';\nimport utc from 'dayjs/plugin/utc';\nimport { get2DayPercentChange, getPercentChange, getBlockFromTimestamp, isAddress, getBlocksFromTimestamps, splitQuery } from '../utils';\nimport { timeframeOptions } from '../constants';\nimport { useLatestBlocks } from './Application';\nimport { updateNameData } from '../utils/data';\nconst UPDATE = 'UPDATE';\nconst UPDATE_TOKEN_TXNS = 'UPDATE_TOKEN_TXNS';\nconst UPDATE_CHART_DATA = 'UPDATE_CHART_DATA';\nconst UPDATE_PRICE_DATA = 'UPDATE_PRICE_DATA';\nconst UPDATE_TOP_TOKENS = ' UPDATE_TOP_TOKENS';\nconst UPDATE_ALL_PAIRS = 'UPDATE_ALL_PAIRS';\nconst TOKEN_PAIRS_KEY = 'TOKEN_PAIRS_KEY';\ndayjs.extend(utc);\nconst TokenDataContext = createContext();\n\nfunction useTokenDataContext() {\n  return useContext(TokenDataContext);\n}\n\nfunction reducer(state, {\n  type,\n  payload\n}) {\n  switch (type) {\n    case UPDATE:\n      {\n        const {\n          tokenAddress,\n          data\n        } = payload;\n        return { ...state,\n          [tokenAddress]: { ...(state === null || state === void 0 ? void 0 : state[tokenAddress]),\n            ...data\n          }\n        };\n      }\n\n    case UPDATE_TOP_TOKENS:\n      {\n        const {\n          topTokens\n        } = payload;\n        let added = {};\n        topTokens && topTokens.map(token => {\n          return added[token.id] = token;\n        });\n        return { ...state,\n          ...added\n        };\n      }\n\n    case UPDATE_TOKEN_TXNS:\n      {\n        const {\n          address,\n          transactions\n        } = payload;\n        return { ...state,\n          [address]: { ...(state === null || state === void 0 ? void 0 : state[address]),\n            txns: transactions\n          }\n        };\n      }\n\n    case UPDATE_CHART_DATA:\n      {\n        const {\n          address,\n          chartData\n        } = payload;\n        return { ...state,\n          [address]: { ...(state === null || state === void 0 ? void 0 : state[address]),\n            chartData\n          }\n        };\n      }\n\n    case UPDATE_PRICE_DATA:\n      {\n        var _state$address;\n\n        const {\n          address,\n          data,\n          timeWindow,\n          interval\n        } = payload;\n        return { ...state,\n          [address]: { ...(state === null || state === void 0 ? void 0 : state[address]),\n            [timeWindow]: { ...(state === null || state === void 0 ? void 0 : (_state$address = state[address]) === null || _state$address === void 0 ? void 0 : _state$address[timeWindow]),\n              [interval]: data\n            }\n          }\n        };\n      }\n\n    case UPDATE_ALL_PAIRS:\n      {\n        const {\n          address,\n          allPairs\n        } = payload;\n        return { ...state,\n          [address]: { ...(state === null || state === void 0 ? void 0 : state[address]),\n            [TOKEN_PAIRS_KEY]: allPairs\n          }\n        };\n      }\n\n    default:\n      {\n        throw Error(`Unexpected action type in DataContext reducer: '${type}'.`);\n      }\n  }\n}\n\nexport default function Provider({\n  children\n}) {\n  const [state, dispatch] = useReducer(reducer, {});\n  const update = useCallback((tokenAddress, data) => {\n    dispatch({\n      type: UPDATE,\n      payload: {\n        tokenAddress,\n        data\n      }\n    });\n  }, []);\n  const updateTopTokens = useCallback(topTokens => {\n    dispatch({\n      type: UPDATE_TOP_TOKENS,\n      payload: {\n        topTokens\n      }\n    });\n  }, []);\n  const updateTokenTxns = useCallback((address, transactions) => {\n    dispatch({\n      type: UPDATE_TOKEN_TXNS,\n      payload: {\n        address,\n        transactions\n      }\n    });\n  }, []);\n  const updateChartData = useCallback((address, chartData) => {\n    dispatch({\n      type: UPDATE_CHART_DATA,\n      payload: {\n        address,\n        chartData\n      }\n    });\n  }, []);\n  const updateAllPairs = useCallback((address, allPairs) => {\n    dispatch({\n      type: UPDATE_ALL_PAIRS,\n      payload: {\n        address,\n        allPairs\n      }\n    });\n  }, []);\n  const updatePriceData = useCallback((address, data, timeWindow, interval) => {\n    dispatch({\n      type: UPDATE_PRICE_DATA,\n      payload: {\n        address,\n        data,\n        timeWindow,\n        interval\n      }\n    });\n  }, []);\n  return /*#__PURE__*/React.createElement(TokenDataContext.Provider, {\n    value: useMemo(() => [state, {\n      update,\n      updateTokenTxns,\n      updateChartData,\n      updateTopTokens,\n      updateAllPairs,\n      updatePriceData\n    }], [state, update, updateTokenTxns, updateChartData, updateTopTokens, updateAllPairs, updatePriceData]),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 174,\n      columnNumber: 5\n    }\n  }, children);\n}\n\nconst getTopTokens = async (ethPrice, ethPriceOld) => {\n  const utcCurrentTime = dayjs();\n  const utcOneDayBack = utcCurrentTime.subtract(1, 'day').unix();\n  const utcTwoDaysBack = utcCurrentTime.subtract(2, 'day').unix();\n  let oneDayBlock = await getBlockFromTimestamp(utcOneDayBack);\n  let twoDayBlock = await getBlockFromTimestamp(utcTwoDaysBack);\n\n  try {\n    var _oneDayResult$data, _twoDayResult$data, _current$data;\n\n    let current = await client.query({\n      query: TOKENS_CURRENT,\n      fetchPolicy: 'cache-first'\n    });\n    let oneDayResult = await client.query({\n      query: TOKENS_DYNAMIC(oneDayBlock),\n      fetchPolicy: 'cache-first'\n    });\n    let twoDayResult = await client.query({\n      query: TOKENS_DYNAMIC(twoDayBlock),\n      fetchPolicy: 'cache-first'\n    });\n    let oneDayData = oneDayResult === null || oneDayResult === void 0 ? void 0 : (_oneDayResult$data = oneDayResult.data) === null || _oneDayResult$data === void 0 ? void 0 : _oneDayResult$data.tokens.reduce((obj, cur, i) => {\n      return { ...obj,\n        [cur.id]: cur\n      };\n    }, {});\n    let twoDayData = twoDayResult === null || twoDayResult === void 0 ? void 0 : (_twoDayResult$data = twoDayResult.data) === null || _twoDayResult$data === void 0 ? void 0 : _twoDayResult$data.tokens.reduce((obj, cur, i) => {\n      return { ...obj,\n        [cur.id]: cur\n      };\n    }, {});\n    let bulkResults = await Promise.all(current && oneDayData && twoDayData && (current === null || current === void 0 ? void 0 : (_current$data = current.data) === null || _current$data === void 0 ? void 0 : _current$data.tokens.map(async token => {\n      var _oneDayHistory$tradeV, _oneDayHistory, _twoDayHistory$tradeV, _twoDayHistory, _oneDayHistory$txCoun, _oneDayHistory2, _twoDayHistory$txCoun, _twoDayHistory2, _oneDayHistory3, _oneDayHistory4, _oneDayHistory5, _oneDayHistory6;\n\n      let data = token; // let liquidityDataThisToken = liquidityData?.[token.id]\n\n      let oneDayHistory = oneDayData === null || oneDayData === void 0 ? void 0 : oneDayData[token.id];\n      let twoDayHistory = twoDayData === null || twoDayData === void 0 ? void 0 : twoDayData[token.id]; // catch the case where token wasnt in top list in previous days\n\n      if (!oneDayHistory) {\n        let oneDayResult = await client.query({\n          query: TOKEN_DATA(token.id, oneDayBlock),\n          fetchPolicy: 'cache-first'\n        });\n        oneDayHistory = oneDayResult.data.tokens[0];\n      }\n\n      if (!twoDayHistory) {\n        let twoDayResult = await client.query({\n          query: TOKEN_DATA(token.id, twoDayBlock),\n          fetchPolicy: 'cache-first'\n        });\n        twoDayHistory = twoDayResult.data.tokens[0];\n      } // calculate percentage changes and daily changes\n\n\n      const [oneDayVolumeUSD, volumeChangeUSD] = get2DayPercentChange(data.tradeVolumeUSD, (_oneDayHistory$tradeV = (_oneDayHistory = oneDayHistory) === null || _oneDayHistory === void 0 ? void 0 : _oneDayHistory.tradeVolumeUSD) !== null && _oneDayHistory$tradeV !== void 0 ? _oneDayHistory$tradeV : 0, (_twoDayHistory$tradeV = (_twoDayHistory = twoDayHistory) === null || _twoDayHistory === void 0 ? void 0 : _twoDayHistory.tradeVolumeUSD) !== null && _twoDayHistory$tradeV !== void 0 ? _twoDayHistory$tradeV : 0);\n      const [oneDayTxns, txnChange] = get2DayPercentChange(data.txCount, (_oneDayHistory$txCoun = (_oneDayHistory2 = oneDayHistory) === null || _oneDayHistory2 === void 0 ? void 0 : _oneDayHistory2.txCount) !== null && _oneDayHistory$txCoun !== void 0 ? _oneDayHistory$txCoun : 0, (_twoDayHistory$txCoun = (_twoDayHistory2 = twoDayHistory) === null || _twoDayHistory2 === void 0 ? void 0 : _twoDayHistory2.txCount) !== null && _twoDayHistory$txCoun !== void 0 ? _twoDayHistory$txCoun : 0);\n      const currentLiquidityUSD = (data === null || data === void 0 ? void 0 : data.totalLiquidity) * ethPrice * (data === null || data === void 0 ? void 0 : data.derivedETH);\n      const oldLiquidityUSD = ((_oneDayHistory3 = oneDayHistory) === null || _oneDayHistory3 === void 0 ? void 0 : _oneDayHistory3.totalLiquidity) * ethPriceOld * ((_oneDayHistory4 = oneDayHistory) === null || _oneDayHistory4 === void 0 ? void 0 : _oneDayHistory4.derivedETH); // percent changes\n\n      const priceChangeUSD = getPercentChange((data === null || data === void 0 ? void 0 : data.derivedETH) * ethPrice, ((_oneDayHistory5 = oneDayHistory) === null || _oneDayHistory5 === void 0 ? void 0 : _oneDayHistory5.derivedETH) ? ((_oneDayHistory6 = oneDayHistory) === null || _oneDayHistory6 === void 0 ? void 0 : _oneDayHistory6.derivedETH) * ethPriceOld : 0); // set data\n\n      data.priceUSD = (data === null || data === void 0 ? void 0 : data.derivedETH) * ethPrice;\n      data.totalLiquidityUSD = currentLiquidityUSD;\n      data.oneDayVolumeUSD = parseFloat(oneDayVolumeUSD);\n      data.volumeChangeUSD = volumeChangeUSD;\n      data.priceChangeUSD = priceChangeUSD;\n      data.liquidityChangeUSD = getPercentChange(currentLiquidityUSD !== null && currentLiquidityUSD !== void 0 ? currentLiquidityUSD : 0, oldLiquidityUSD !== null && oldLiquidityUSD !== void 0 ? oldLiquidityUSD : 0);\n      data.oneDayTxns = oneDayTxns;\n      data.txnChange = txnChange; // new tokens\n\n      if (!oneDayHistory && data) {\n        data.oneDayVolumeUSD = data.tradeVolumeUSD;\n        data.oneDayVolumeETH = data.tradeVolume * data.derivedETH;\n        data.oneDayTxns = data.txCount;\n      } // update name data for\n\n\n      updateNameData({\n        token0: data\n      }); // HOTFIX for Aave\n\n      if (data.id === '0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9') {\n        const aaveData = await client.query({\n          query: PAIR_DATA('0xdfc14d2af169b0d36c4eff567ada9b2e0cae044f'),\n          fetchPolicy: 'cache-first'\n        });\n        const result = aaveData.data.pairs[0];\n        data.totalLiquidityUSD = parseFloat(result.reserveUSD) / 2;\n        data.liquidityChangeUSD = 0;\n        data.priceChangeUSD = 0;\n      }\n\n      return data;\n    })));\n    return bulkResults; // calculate percentage changes and daily changes\n  } catch (e) {\n    console.log(e);\n  }\n};\n\nconst getTokenData = async (address, ethPrice, ethPriceOld) => {\n  const utcCurrentTime = dayjs();\n  const utcOneDayBack = utcCurrentTime.subtract(1, 'day').startOf('minute').unix();\n  const utcTwoDaysBack = utcCurrentTime.subtract(2, 'day').startOf('minute').unix();\n  let oneDayBlock = await getBlockFromTimestamp(utcOneDayBack);\n  let twoDayBlock = await getBlockFromTimestamp(utcTwoDaysBack); // initialize data arrays\n\n  let data = {};\n  let oneDayData = {};\n  let twoDayData = {};\n\n  try {\n    var _result$data, _result$data$tokens, _oneDayData$tradeVolu, _oneDayData, _twoDayData$tradeVolu, _twoDayData, _oneDayData$untracked, _oneDayData2, _twoDayData$untracked, _twoDayData2, _oneDayData$txCount, _oneDayData3, _twoDayData$txCount, _twoDayData3, _data, _oneDayData$derivedET, _oneDayData4, _data2, _data3, _oneDayData5, _oneDayData6, _data4;\n\n    // fetch all current and historical data\n    let result = await client.query({\n      query: TOKEN_DATA(address),\n      fetchPolicy: 'cache-first'\n    });\n    data = result === null || result === void 0 ? void 0 : (_result$data = result.data) === null || _result$data === void 0 ? void 0 : (_result$data$tokens = _result$data.tokens) === null || _result$data$tokens === void 0 ? void 0 : _result$data$tokens[0]; // get results from 24 hours in past\n\n    let oneDayResult = await client.query({\n      query: TOKEN_DATA(address, oneDayBlock),\n      fetchPolicy: 'cache-first'\n    });\n    oneDayData = oneDayResult.data.tokens[0]; // get results from 48 hours in past\n\n    let twoDayResult = await client.query({\n      query: TOKEN_DATA(address, twoDayBlock),\n      fetchPolicy: 'cache-first'\n    });\n    twoDayData = twoDayResult.data.tokens[0]; // catch the case where token wasnt in top list in previous days\n\n    if (!oneDayData) {\n      let oneDayResult = await client.query({\n        query: TOKEN_DATA(address, oneDayBlock),\n        fetchPolicy: 'cache-first'\n      });\n      oneDayData = oneDayResult.data.tokens[0];\n    }\n\n    if (!twoDayData) {\n      let twoDayResult = await client.query({\n        query: TOKEN_DATA(address, twoDayBlock),\n        fetchPolicy: 'cache-first'\n      });\n      twoDayData = twoDayResult.data.tokens[0];\n    } // calculate percentage changes and daily changes\n\n\n    const [oneDayVolumeUSD, volumeChangeUSD] = get2DayPercentChange(data.tradeVolumeUSD, (_oneDayData$tradeVolu = (_oneDayData = oneDayData) === null || _oneDayData === void 0 ? void 0 : _oneDayData.tradeVolumeUSD) !== null && _oneDayData$tradeVolu !== void 0 ? _oneDayData$tradeVolu : 0, (_twoDayData$tradeVolu = (_twoDayData = twoDayData) === null || _twoDayData === void 0 ? void 0 : _twoDayData.tradeVolumeUSD) !== null && _twoDayData$tradeVolu !== void 0 ? _twoDayData$tradeVolu : 0); // calculate percentage changes and daily changes\n\n    const [oneDayVolumeUT, volumeChangeUT] = get2DayPercentChange(data.untrackedVolumeUSD, (_oneDayData$untracked = (_oneDayData2 = oneDayData) === null || _oneDayData2 === void 0 ? void 0 : _oneDayData2.untrackedVolumeUSD) !== null && _oneDayData$untracked !== void 0 ? _oneDayData$untracked : 0, (_twoDayData$untracked = (_twoDayData2 = twoDayData) === null || _twoDayData2 === void 0 ? void 0 : _twoDayData2.untrackedVolumeUSD) !== null && _twoDayData$untracked !== void 0 ? _twoDayData$untracked : 0); // calculate percentage changes and daily changes\n\n    const [oneDayTxns, txnChange] = get2DayPercentChange(data.txCount, (_oneDayData$txCount = (_oneDayData3 = oneDayData) === null || _oneDayData3 === void 0 ? void 0 : _oneDayData3.txCount) !== null && _oneDayData$txCount !== void 0 ? _oneDayData$txCount : 0, (_twoDayData$txCount = (_twoDayData3 = twoDayData) === null || _twoDayData3 === void 0 ? void 0 : _twoDayData3.txCount) !== null && _twoDayData$txCount !== void 0 ? _twoDayData$txCount : 0);\n    const priceChangeUSD = getPercentChange(((_data = data) === null || _data === void 0 ? void 0 : _data.derivedETH) * ethPrice, parseFloat((_oneDayData$derivedET = (_oneDayData4 = oneDayData) === null || _oneDayData4 === void 0 ? void 0 : _oneDayData4.derivedETH) !== null && _oneDayData$derivedET !== void 0 ? _oneDayData$derivedET : 0) * ethPriceOld);\n    const currentLiquidityUSD = ((_data2 = data) === null || _data2 === void 0 ? void 0 : _data2.totalLiquidity) * ethPrice * ((_data3 = data) === null || _data3 === void 0 ? void 0 : _data3.derivedETH);\n    const oldLiquidityUSD = ((_oneDayData5 = oneDayData) === null || _oneDayData5 === void 0 ? void 0 : _oneDayData5.totalLiquidity) * ethPriceOld * ((_oneDayData6 = oneDayData) === null || _oneDayData6 === void 0 ? void 0 : _oneDayData6.derivedETH); // set data\n\n    data.priceUSD = ((_data4 = data) === null || _data4 === void 0 ? void 0 : _data4.derivedETH) * ethPrice;\n    data.totalLiquidityUSD = currentLiquidityUSD;\n    data.oneDayVolumeUSD = oneDayVolumeUSD;\n    data.volumeChangeUSD = volumeChangeUSD;\n    data.priceChangeUSD = priceChangeUSD;\n    data.oneDayVolumeUT = oneDayVolumeUT;\n    data.volumeChangeUT = volumeChangeUT;\n    const liquidityChangeUSD = getPercentChange(currentLiquidityUSD !== null && currentLiquidityUSD !== void 0 ? currentLiquidityUSD : 0, oldLiquidityUSD !== null && oldLiquidityUSD !== void 0 ? oldLiquidityUSD : 0);\n    data.liquidityChangeUSD = liquidityChangeUSD;\n    data.oneDayTxns = oneDayTxns;\n    data.txnChange = txnChange; // new tokens\n\n    if (!oneDayData && data) {\n      data.oneDayVolumeUSD = data.tradeVolumeUSD;\n      data.oneDayVolumeETH = data.tradeVolume * data.derivedETH;\n      data.oneDayTxns = data.txCount;\n    } // update name data for\n\n\n    updateNameData({\n      token0: data\n    }); // HOTFIX for Aave\n\n    if (data.id === '0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9') {\n      const aaveData = await client.query({\n        query: PAIR_DATA('0xdfc14d2af169b0d36c4eff567ada9b2e0cae044f'),\n        fetchPolicy: 'cache-first'\n      });\n      const result = aaveData.data.pairs[0];\n      data.totalLiquidityUSD = parseFloat(result.reserveUSD) / 2;\n      data.liquidityChangeUSD = 0;\n      data.priceChangeUSD = 0;\n    }\n  } catch (e) {\n    console.log(e);\n  }\n\n  return data;\n};\n\nconst getTokenTransactions = async allPairsFormatted => {\n  const transactions = {};\n\n  try {\n    let result = await client.query({\n      query: FILTERED_TRANSACTIONS,\n      variables: {\n        allPairs: allPairsFormatted\n      },\n      fetchPolicy: 'cache-first'\n    });\n    transactions.mints = result.data.mints;\n    transactions.burns = result.data.burns;\n    transactions.swaps = result.data.swaps;\n  } catch (e) {\n    console.log(e);\n  }\n\n  return transactions;\n};\n\nconst getTokenPairs = async tokenAddress => {\n  try {\n    var _result$data2, _result$data3;\n\n    // fetch all current and historical data\n    let result = await client.query({\n      query: TOKEN_DATA(tokenAddress),\n      fetchPolicy: 'cache-first'\n    });\n    return (_result$data2 = result.data) === null || _result$data2 === void 0 ? void 0 : _result$data2['pairs0'].concat((_result$data3 = result.data) === null || _result$data3 === void 0 ? void 0 : _result$data3['pairs1']);\n  } catch (e) {\n    console.log(e);\n  }\n};\n\nconst getIntervalTokenData = async (tokenAddress, startTime, interval = 3600, latestBlock) => {\n  const utcEndTime = dayjs.utc();\n  let time = startTime; // create an array of hour start times until we reach current hour\n  // buffer by half hour to catch case where graph isnt synced to latest block\n\n  const timestamps = [];\n\n  while (time < utcEndTime.unix()) {\n    timestamps.push(time);\n    time += interval;\n  } // backout if invalid timestamp format\n\n\n  if (timestamps.length === 0) {\n    return [];\n  } // once you have all the timestamps, get the blocks for each timestamp in a bulk query\n\n\n  let blocks;\n\n  try {\n    blocks = await getBlocksFromTimestamps(timestamps, 100); // catch failing case\n\n    if (!blocks || blocks.length === 0) {\n      return [];\n    }\n\n    if (latestBlock) {\n      blocks = blocks.filter(b => {\n        return parseFloat(b.number) <= parseFloat(latestBlock);\n      });\n    }\n\n    let result = await splitQuery(PRICES_BY_BLOCK, client, [tokenAddress], blocks, 50); // format token ETH price results\n\n    let values = [];\n\n    for (var row in result) {\n      var _result$row;\n\n      let timestamp = row.split('t')[1];\n      let derivedETH = parseFloat((_result$row = result[row]) === null || _result$row === void 0 ? void 0 : _result$row.derivedETH);\n\n      if (timestamp) {\n        values.push({\n          timestamp,\n          derivedETH\n        });\n      }\n    } // go through eth usd prices and assign to original values array\n\n\n    let index = 0;\n\n    for (var brow in result) {\n      let timestamp = brow.split('b')[1];\n\n      if (timestamp) {\n        values[index].priceUSD = result[brow].ethPrice * values[index].derivedETH;\n        index += 1;\n      }\n    }\n\n    let formattedHistory = []; // for each hour, construct the open and close price\n\n    for (let i = 0; i < values.length - 1; i++) {\n      formattedHistory.push({\n        timestamp: values[i].timestamp,\n        open: parseFloat(values[i].priceUSD),\n        close: parseFloat(values[i + 1].priceUSD)\n      });\n    }\n\n    return formattedHistory;\n  } catch (e) {\n    console.log(e);\n    console.log('error fetching blocks');\n    return [];\n  }\n};\n\nconst getTokenChartData = async tokenAddress => {\n  let data = [];\n  const utcEndTime = dayjs.utc();\n  let utcStartTime = utcEndTime.subtract(1, 'year');\n  let startTime = utcStartTime.startOf('minute').unix() - 1;\n\n  try {\n    let allFound = false;\n    let skip = 0;\n\n    while (!allFound) {\n      let result = await client.query({\n        query: TOKEN_CHART,\n        variables: {\n          tokenAddr: tokenAddress,\n          skip\n        },\n        fetchPolicy: 'cache-first'\n      });\n\n      if (result.data.tokenDayDatas.length < 1000) {\n        allFound = true;\n      }\n\n      skip += 1000;\n      data = data.concat(result.data.tokenDayDatas);\n    }\n\n    let dayIndexSet = new Set();\n    let dayIndexArray = [];\n    const oneDay = 24 * 60 * 60;\n    data.forEach((dayData, i) => {\n      // add the day index to the set of days\n      dayIndexSet.add((data[i].date / oneDay).toFixed(0));\n      dayIndexArray.push(data[i]);\n      dayData.dailyVolumeUSD = parseFloat(dayData.dailyVolumeUSD);\n    }); // fill in empty days\n\n    let timestamp = data[0] && data[0].date ? data[0].date : startTime;\n    let latestLiquidityUSD = data[0] && data[0].totalLiquidityUSD;\n    let latestPriceUSD = data[0] && data[0].priceUSD;\n    let latestPairDatas = data[0] && data[0].mostLiquidPairs;\n    let index = 1;\n\n    while (timestamp < utcEndTime.startOf('minute').unix() - oneDay) {\n      const nextDay = timestamp + oneDay;\n      let currentDayIndex = (nextDay / oneDay).toFixed(0);\n\n      if (!dayIndexSet.has(currentDayIndex)) {\n        data.push({\n          date: nextDay,\n          dayString: nextDay,\n          dailyVolumeUSD: 0,\n          priceUSD: latestPriceUSD,\n          totalLiquidityUSD: latestLiquidityUSD,\n          mostLiquidPairs: latestPairDatas\n        });\n      } else {\n        latestLiquidityUSD = dayIndexArray[index].totalLiquidityUSD;\n        latestPriceUSD = dayIndexArray[index].priceUSD;\n        latestPairDatas = dayIndexArray[index].mostLiquidPairs;\n        index = index + 1;\n      }\n\n      timestamp = nextDay;\n    }\n\n    data = data.sort((a, b) => parseInt(a.date) > parseInt(b.date) ? 1 : -1);\n  } catch (e) {\n    console.log(e);\n  }\n\n  return data;\n};\n\nexport function Updater() {\n  const [, {\n    updateTopTokens\n  }] = useTokenDataContext();\n  const [ethPrice, ethPriceOld] = useEthPrice();\n  useEffect(() => {\n    async function getData() {\n      // get top pairs for overview list\n      let topTokens = await getTopTokens(ethPrice, ethPriceOld);\n      topTokens && updateTopTokens(topTokens);\n    }\n\n    ethPrice && ethPriceOld && getData();\n  }, [ethPrice, ethPriceOld, updateTopTokens]);\n  return null;\n}\nexport function useTokenData(tokenAddress) {\n  const [state, {\n    update\n  }] = useTokenDataContext();\n  const [ethPrice, ethPriceOld] = useEthPrice();\n  const tokenData = state === null || state === void 0 ? void 0 : state[tokenAddress];\n  useEffect(() => {\n    if (!tokenData && ethPrice && ethPriceOld && isAddress(tokenAddress)) {\n      getTokenData(tokenAddress, ethPrice, ethPriceOld).then(data => {\n        update(tokenAddress, data);\n      });\n    }\n  }, [ethPrice, ethPriceOld, tokenAddress, tokenData, update]);\n  return tokenData || {};\n}\nexport function useTokenTransactions(tokenAddress) {\n  var _state$tokenAddress;\n\n  const [state, {\n    updateTokenTxns\n  }] = useTokenDataContext();\n  const tokenTxns = state === null || state === void 0 ? void 0 : (_state$tokenAddress = state[tokenAddress]) === null || _state$tokenAddress === void 0 ? void 0 : _state$tokenAddress.txns;\n  const allPairsFormatted = state[tokenAddress] && state[tokenAddress].TOKEN_PAIRS_KEY && state[tokenAddress].TOKEN_PAIRS_KEY.map(pair => {\n    return pair.id;\n  });\n  useEffect(() => {\n    async function checkForTxns() {\n      if (!tokenTxns && allPairsFormatted) {\n        let transactions = await getTokenTransactions(allPairsFormatted);\n        updateTokenTxns(tokenAddress, transactions);\n      }\n    }\n\n    checkForTxns();\n  }, [tokenTxns, tokenAddress, updateTokenTxns, allPairsFormatted]);\n  return tokenTxns || [];\n}\nexport function useTokenPairs(tokenAddress) {\n  var _state$tokenAddress2;\n\n  const [state, {\n    updateAllPairs\n  }] = useTokenDataContext();\n  const tokenPairs = state === null || state === void 0 ? void 0 : (_state$tokenAddress2 = state[tokenAddress]) === null || _state$tokenAddress2 === void 0 ? void 0 : _state$tokenAddress2[TOKEN_PAIRS_KEY];\n  useEffect(() => {\n    async function fetchData() {\n      let allPairs = await getTokenPairs(tokenAddress);\n      updateAllPairs(tokenAddress, allPairs);\n    }\n\n    if (!tokenPairs && isAddress(tokenAddress)) {\n      fetchData();\n    }\n  }, [tokenAddress, tokenPairs, updateAllPairs]);\n  return tokenPairs || [];\n}\nexport function useTokenChartData(tokenAddress) {\n  var _state$tokenAddress3;\n\n  const [state, {\n    updateChartData\n  }] = useTokenDataContext();\n  const chartData = state === null || state === void 0 ? void 0 : (_state$tokenAddress3 = state[tokenAddress]) === null || _state$tokenAddress3 === void 0 ? void 0 : _state$tokenAddress3.chartData;\n  useEffect(() => {\n    async function checkForChartData() {\n      if (!chartData) {\n        let data = await getTokenChartData(tokenAddress);\n        updateChartData(tokenAddress, data);\n      }\n    }\n\n    checkForChartData();\n  }, [chartData, tokenAddress, updateChartData]);\n  return chartData;\n}\n/**\n * get candlestick data for a token - saves in context based on the window and the\n * interval size\n * @param {*} tokenAddress\n * @param {*} timeWindow // a preset time window from constant - how far back to look\n * @param {*} interval  // the chunk size in seconds - default is 1 hour of 3600s\n */\n\nexport function useTokenPriceData(tokenAddress, timeWindow, interval = 3600) {\n  var _state$tokenAddress4, _state$tokenAddress4$;\n\n  const [state, {\n    updatePriceData\n  }] = useTokenDataContext();\n  const chartData = state === null || state === void 0 ? void 0 : (_state$tokenAddress4 = state[tokenAddress]) === null || _state$tokenAddress4 === void 0 ? void 0 : (_state$tokenAddress4$ = _state$tokenAddress4[timeWindow]) === null || _state$tokenAddress4$ === void 0 ? void 0 : _state$tokenAddress4$[interval];\n  const [latestBlock] = useLatestBlocks();\n  useEffect(() => {\n    const currentTime = dayjs.utc();\n    const windowSize = timeWindow === timeframeOptions.MONTH ? 'month' : 'week';\n    const startTime = timeWindow === timeframeOptions.ALL_TIME ? 1589760000 : currentTime.subtract(1, windowSize).startOf('hour').unix();\n\n    async function fetch() {\n      let data = await getIntervalTokenData(tokenAddress, startTime, interval, latestBlock);\n      updatePriceData(tokenAddress, data, timeWindow, interval);\n    }\n\n    if (!chartData) {\n      fetch();\n    }\n  }, [chartData, interval, timeWindow, tokenAddress, updatePriceData, latestBlock]);\n  return chartData;\n}\nexport function useAllTokenData() {\n  const [state] = useTokenDataContext();\n  return state;\n}","map":{"version":3,"sources":["/Users/macbook/Desktop/Pega/pegaswap-docs/src/contexts/TokenData.js"],"names":["React","createContext","useContext","useReducer","useMemo","useCallback","useEffect","client","TOKEN_DATA","FILTERED_TRANSACTIONS","TOKEN_CHART","TOKENS_CURRENT","TOKENS_DYNAMIC","PRICES_BY_BLOCK","PAIR_DATA","useEthPrice","dayjs","utc","get2DayPercentChange","getPercentChange","getBlockFromTimestamp","isAddress","getBlocksFromTimestamps","splitQuery","timeframeOptions","useLatestBlocks","updateNameData","UPDATE","UPDATE_TOKEN_TXNS","UPDATE_CHART_DATA","UPDATE_PRICE_DATA","UPDATE_TOP_TOKENS","UPDATE_ALL_PAIRS","TOKEN_PAIRS_KEY","extend","TokenDataContext","useTokenDataContext","reducer","state","type","payload","tokenAddress","data","topTokens","added","map","token","id","address","transactions","txns","chartData","timeWindow","interval","allPairs","Error","Provider","children","dispatch","update","updateTopTokens","updateTokenTxns","updateChartData","updateAllPairs","updatePriceData","getTopTokens","ethPrice","ethPriceOld","utcCurrentTime","utcOneDayBack","subtract","unix","utcTwoDaysBack","oneDayBlock","twoDayBlock","current","query","fetchPolicy","oneDayResult","twoDayResult","oneDayData","tokens","reduce","obj","cur","i","twoDayData","bulkResults","Promise","all","oneDayHistory","twoDayHistory","oneDayVolumeUSD","volumeChangeUSD","tradeVolumeUSD","oneDayTxns","txnChange","txCount","currentLiquidityUSD","totalLiquidity","derivedETH","oldLiquidityUSD","priceChangeUSD","priceUSD","totalLiquidityUSD","parseFloat","liquidityChangeUSD","oneDayVolumeETH","tradeVolume","token0","aaveData","result","pairs","reserveUSD","e","console","log","getTokenData","startOf","oneDayVolumeUT","volumeChangeUT","untrackedVolumeUSD","getTokenTransactions","allPairsFormatted","variables","mints","burns","swaps","getTokenPairs","concat","getIntervalTokenData","startTime","latestBlock","utcEndTime","time","timestamps","push","length","blocks","filter","b","number","values","row","timestamp","split","index","brow","formattedHistory","open","close","getTokenChartData","utcStartTime","allFound","skip","tokenAddr","tokenDayDatas","dayIndexSet","Set","dayIndexArray","oneDay","forEach","dayData","add","date","toFixed","dailyVolumeUSD","latestLiquidityUSD","latestPriceUSD","latestPairDatas","mostLiquidPairs","nextDay","currentDayIndex","has","dayString","sort","a","parseInt","Updater","getData","useTokenData","tokenData","then","useTokenTransactions","tokenTxns","pair","checkForTxns","useTokenPairs","tokenPairs","fetchData","useTokenChartData","checkForChartData","useTokenPriceData","currentTime","windowSize","MONTH","ALL_TIME","fetch","useAllTokenData"],"mappings":"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","sourcesContent":["import React, { createContext, useContext, useReducer, useMemo, useCallback, useEffect } from 'react'\n\nimport { client } from '../apollo/client'\nimport {\n  TOKEN_DATA,\n  FILTERED_TRANSACTIONS,\n  TOKEN_CHART,\n  TOKENS_CURRENT,\n  TOKENS_DYNAMIC,\n  PRICES_BY_BLOCK,\n  PAIR_DATA,\n} from '../apollo/queries'\n\nimport { useEthPrice } from './GlobalData'\n\nimport dayjs from 'dayjs'\nimport utc from 'dayjs/plugin/utc'\n\nimport {\n  get2DayPercentChange,\n  getPercentChange,\n  getBlockFromTimestamp,\n  isAddress,\n  getBlocksFromTimestamps,\n  splitQuery,\n} from '../utils'\nimport { timeframeOptions } from '../constants'\nimport { useLatestBlocks } from './Application'\nimport { updateNameData } from '../utils/data'\n\nconst UPDATE = 'UPDATE'\nconst UPDATE_TOKEN_TXNS = 'UPDATE_TOKEN_TXNS'\nconst UPDATE_CHART_DATA = 'UPDATE_CHART_DATA'\nconst UPDATE_PRICE_DATA = 'UPDATE_PRICE_DATA'\nconst UPDATE_TOP_TOKENS = ' UPDATE_TOP_TOKENS'\nconst UPDATE_ALL_PAIRS = 'UPDATE_ALL_PAIRS'\n\nconst TOKEN_PAIRS_KEY = 'TOKEN_PAIRS_KEY'\n\ndayjs.extend(utc)\n\nconst TokenDataContext = createContext()\n\nfunction useTokenDataContext() {\n  return useContext(TokenDataContext)\n}\n\nfunction reducer(state, { type, payload }) {\n  switch (type) {\n    case UPDATE: {\n      const { tokenAddress, data } = payload\n      return {\n        ...state,\n        [tokenAddress]: {\n          ...state?.[tokenAddress],\n          ...data,\n        },\n      }\n    }\n    case UPDATE_TOP_TOKENS: {\n      const { topTokens } = payload\n      let added = {}\n      topTokens &&\n        topTokens.map((token) => {\n          return (added[token.id] = token)\n        })\n      return {\n        ...state,\n        ...added,\n      }\n    }\n\n    case UPDATE_TOKEN_TXNS: {\n      const { address, transactions } = payload\n      return {\n        ...state,\n        [address]: {\n          ...state?.[address],\n          txns: transactions,\n        },\n      }\n    }\n    case UPDATE_CHART_DATA: {\n      const { address, chartData } = payload\n      return {\n        ...state,\n        [address]: {\n          ...state?.[address],\n          chartData,\n        },\n      }\n    }\n\n    case UPDATE_PRICE_DATA: {\n      const { address, data, timeWindow, interval } = payload\n      return {\n        ...state,\n        [address]: {\n          ...state?.[address],\n          [timeWindow]: {\n            ...state?.[address]?.[timeWindow],\n            [interval]: data,\n          },\n        },\n      }\n    }\n\n    case UPDATE_ALL_PAIRS: {\n      const { address, allPairs } = payload\n      return {\n        ...state,\n        [address]: {\n          ...state?.[address],\n          [TOKEN_PAIRS_KEY]: allPairs,\n        },\n      }\n    }\n    default: {\n      throw Error(`Unexpected action type in DataContext reducer: '${type}'.`)\n    }\n  }\n}\n\nexport default function Provider({ children }) {\n  const [state, dispatch] = useReducer(reducer, {})\n  const update = useCallback((tokenAddress, data) => {\n    dispatch({\n      type: UPDATE,\n      payload: {\n        tokenAddress,\n        data,\n      },\n    })\n  }, [])\n\n  const updateTopTokens = useCallback((topTokens) => {\n    dispatch({\n      type: UPDATE_TOP_TOKENS,\n      payload: {\n        topTokens,\n      },\n    })\n  }, [])\n\n  const updateTokenTxns = useCallback((address, transactions) => {\n    dispatch({\n      type: UPDATE_TOKEN_TXNS,\n      payload: { address, transactions },\n    })\n  }, [])\n\n  const updateChartData = useCallback((address, chartData) => {\n    dispatch({\n      type: UPDATE_CHART_DATA,\n      payload: { address, chartData },\n    })\n  }, [])\n\n  const updateAllPairs = useCallback((address, allPairs) => {\n    dispatch({\n      type: UPDATE_ALL_PAIRS,\n      payload: { address, allPairs },\n    })\n  }, [])\n\n  const updatePriceData = useCallback((address, data, timeWindow, interval) => {\n    dispatch({\n      type: UPDATE_PRICE_DATA,\n      payload: { address, data, timeWindow, interval },\n    })\n  }, [])\n\n  return (\n    <TokenDataContext.Provider\n      value={useMemo(\n        () => [\n          state,\n          {\n            update,\n            updateTokenTxns,\n            updateChartData,\n            updateTopTokens,\n            updateAllPairs,\n            updatePriceData,\n          },\n        ],\n        [state, update, updateTokenTxns, updateChartData, updateTopTokens, updateAllPairs, updatePriceData]\n      )}\n    >\n      {children}\n    </TokenDataContext.Provider>\n  )\n}\n\nconst getTopTokens = async (ethPrice, ethPriceOld) => {\n  const utcCurrentTime = dayjs()\n  const utcOneDayBack = utcCurrentTime.subtract(1, 'day').unix()\n  const utcTwoDaysBack = utcCurrentTime.subtract(2, 'day').unix()\n  let oneDayBlock = await getBlockFromTimestamp(utcOneDayBack)\n  let twoDayBlock = await getBlockFromTimestamp(utcTwoDaysBack)\n\n  try {\n    let current = await client.query({\n      query: TOKENS_CURRENT,\n      fetchPolicy: 'cache-first',\n    })\n\n    let oneDayResult = await client.query({\n      query: TOKENS_DYNAMIC(oneDayBlock),\n      fetchPolicy: 'cache-first',\n    })\n\n    let twoDayResult = await client.query({\n      query: TOKENS_DYNAMIC(twoDayBlock),\n      fetchPolicy: 'cache-first',\n    })\n\n    let oneDayData = oneDayResult?.data?.tokens.reduce((obj, cur, i) => {\n      return { ...obj, [cur.id]: cur }\n    }, {})\n\n    let twoDayData = twoDayResult?.data?.tokens.reduce((obj, cur, i) => {\n      return { ...obj, [cur.id]: cur }\n    }, {})\n\n    let bulkResults = await Promise.all(\n      current &&\n        oneDayData &&\n        twoDayData &&\n        current?.data?.tokens.map(async (token) => {\n          let data = token\n\n          // let liquidityDataThisToken = liquidityData?.[token.id]\n          let oneDayHistory = oneDayData?.[token.id]\n          let twoDayHistory = twoDayData?.[token.id]\n\n          // catch the case where token wasnt in top list in previous days\n          if (!oneDayHistory) {\n            let oneDayResult = await client.query({\n              query: TOKEN_DATA(token.id, oneDayBlock),\n              fetchPolicy: 'cache-first',\n            })\n            oneDayHistory = oneDayResult.data.tokens[0]\n          }\n          if (!twoDayHistory) {\n            let twoDayResult = await client.query({\n              query: TOKEN_DATA(token.id, twoDayBlock),\n              fetchPolicy: 'cache-first',\n            })\n            twoDayHistory = twoDayResult.data.tokens[0]\n          }\n\n          // calculate percentage changes and daily changes\n          const [oneDayVolumeUSD, volumeChangeUSD] = get2DayPercentChange(\n            data.tradeVolumeUSD,\n            oneDayHistory?.tradeVolumeUSD ?? 0,\n            twoDayHistory?.tradeVolumeUSD ?? 0\n          )\n          const [oneDayTxns, txnChange] = get2DayPercentChange(\n            data.txCount,\n            oneDayHistory?.txCount ?? 0,\n            twoDayHistory?.txCount ?? 0\n          )\n\n          const currentLiquidityUSD = data?.totalLiquidity * ethPrice * data?.derivedETH\n          const oldLiquidityUSD = oneDayHistory?.totalLiquidity * ethPriceOld * oneDayHistory?.derivedETH\n\n          // percent changes\n          const priceChangeUSD = getPercentChange(\n            data?.derivedETH * ethPrice,\n            oneDayHistory?.derivedETH ? oneDayHistory?.derivedETH * ethPriceOld : 0\n          )\n\n          // set data\n          data.priceUSD = data?.derivedETH * ethPrice\n          data.totalLiquidityUSD = currentLiquidityUSD\n          data.oneDayVolumeUSD = parseFloat(oneDayVolumeUSD)\n          data.volumeChangeUSD = volumeChangeUSD\n          data.priceChangeUSD = priceChangeUSD\n          data.liquidityChangeUSD = getPercentChange(currentLiquidityUSD ?? 0, oldLiquidityUSD ?? 0)\n          data.oneDayTxns = oneDayTxns\n          data.txnChange = txnChange\n\n          // new tokens\n          if (!oneDayHistory && data) {\n            data.oneDayVolumeUSD = data.tradeVolumeUSD\n            data.oneDayVolumeETH = data.tradeVolume * data.derivedETH\n            data.oneDayTxns = data.txCount\n          }\n\n          // update name data for\n          updateNameData({\n            token0: data,\n          })\n\n          // HOTFIX for Aave\n          if (data.id === '0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9') {\n            const aaveData = await client.query({\n              query: PAIR_DATA('0xdfc14d2af169b0d36c4eff567ada9b2e0cae044f'),\n              fetchPolicy: 'cache-first',\n            })\n            const result = aaveData.data.pairs[0]\n            data.totalLiquidityUSD = parseFloat(result.reserveUSD) / 2\n            data.liquidityChangeUSD = 0\n            data.priceChangeUSD = 0\n          }\n\n          return data\n        })\n    )\n\n    return bulkResults\n\n    // calculate percentage changes and daily changes\n  } catch (e) {\n    console.log(e)\n  }\n}\n\nconst getTokenData = async (address, ethPrice, ethPriceOld) => {\n  const utcCurrentTime = dayjs()\n  const utcOneDayBack = utcCurrentTime.subtract(1, 'day').startOf('minute').unix()\n  const utcTwoDaysBack = utcCurrentTime.subtract(2, 'day').startOf('minute').unix()\n  let oneDayBlock = await getBlockFromTimestamp(utcOneDayBack)\n  let twoDayBlock = await getBlockFromTimestamp(utcTwoDaysBack)\n\n  // initialize data arrays\n  let data = {}\n  let oneDayData = {}\n  let twoDayData = {}\n\n  try {\n    // fetch all current and historical data\n    let result = await client.query({\n      query: TOKEN_DATA(address),\n      fetchPolicy: 'cache-first',\n    })\n    data = result?.data?.tokens?.[0]\n\n    // get results from 24 hours in past\n    let oneDayResult = await client.query({\n      query: TOKEN_DATA(address, oneDayBlock),\n      fetchPolicy: 'cache-first',\n    })\n    oneDayData = oneDayResult.data.tokens[0]\n\n    // get results from 48 hours in past\n    let twoDayResult = await client.query({\n      query: TOKEN_DATA(address, twoDayBlock),\n      fetchPolicy: 'cache-first',\n    })\n    twoDayData = twoDayResult.data.tokens[0]\n\n    // catch the case where token wasnt in top list in previous days\n    if (!oneDayData) {\n      let oneDayResult = await client.query({\n        query: TOKEN_DATA(address, oneDayBlock),\n        fetchPolicy: 'cache-first',\n      })\n      oneDayData = oneDayResult.data.tokens[0]\n    }\n    if (!twoDayData) {\n      let twoDayResult = await client.query({\n        query: TOKEN_DATA(address, twoDayBlock),\n        fetchPolicy: 'cache-first',\n      })\n      twoDayData = twoDayResult.data.tokens[0]\n    }\n\n    // calculate percentage changes and daily changes\n    const [oneDayVolumeUSD, volumeChangeUSD] = get2DayPercentChange(\n      data.tradeVolumeUSD,\n      oneDayData?.tradeVolumeUSD ?? 0,\n      twoDayData?.tradeVolumeUSD ?? 0\n    )\n\n    // calculate percentage changes and daily changes\n    const [oneDayVolumeUT, volumeChangeUT] = get2DayPercentChange(\n      data.untrackedVolumeUSD,\n      oneDayData?.untrackedVolumeUSD ?? 0,\n      twoDayData?.untrackedVolumeUSD ?? 0\n    )\n\n    // calculate percentage changes and daily changes\n    const [oneDayTxns, txnChange] = get2DayPercentChange(\n      data.txCount,\n      oneDayData?.txCount ?? 0,\n      twoDayData?.txCount ?? 0\n    )\n\n    const priceChangeUSD = getPercentChange(\n      data?.derivedETH * ethPrice,\n      parseFloat(oneDayData?.derivedETH ?? 0) * ethPriceOld\n    )\n\n    const currentLiquidityUSD = data?.totalLiquidity * ethPrice * data?.derivedETH\n    const oldLiquidityUSD = oneDayData?.totalLiquidity * ethPriceOld * oneDayData?.derivedETH\n\n    // set data\n    data.priceUSD = data?.derivedETH * ethPrice\n    data.totalLiquidityUSD = currentLiquidityUSD\n    data.oneDayVolumeUSD = oneDayVolumeUSD\n    data.volumeChangeUSD = volumeChangeUSD\n    data.priceChangeUSD = priceChangeUSD\n    data.oneDayVolumeUT = oneDayVolumeUT\n    data.volumeChangeUT = volumeChangeUT\n    const liquidityChangeUSD = getPercentChange(currentLiquidityUSD ?? 0, oldLiquidityUSD ?? 0)\n    data.liquidityChangeUSD = liquidityChangeUSD\n    data.oneDayTxns = oneDayTxns\n    data.txnChange = txnChange\n\n    // new tokens\n    if (!oneDayData && data) {\n      data.oneDayVolumeUSD = data.tradeVolumeUSD\n      data.oneDayVolumeETH = data.tradeVolume * data.derivedETH\n      data.oneDayTxns = data.txCount\n    }\n\n    // update name data for\n    updateNameData({\n      token0: data,\n    })\n\n    // HOTFIX for Aave\n    if (data.id === '0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9') {\n      const aaveData = await client.query({\n        query: PAIR_DATA('0xdfc14d2af169b0d36c4eff567ada9b2e0cae044f'),\n        fetchPolicy: 'cache-first',\n      })\n      const result = aaveData.data.pairs[0]\n      data.totalLiquidityUSD = parseFloat(result.reserveUSD) / 2\n      data.liquidityChangeUSD = 0\n      data.priceChangeUSD = 0\n    }\n  } catch (e) {\n    console.log(e)\n  }\n  return data\n}\n\nconst getTokenTransactions = async (allPairsFormatted) => {\n  const transactions = {}\n  try {\n    let result = await client.query({\n      query: FILTERED_TRANSACTIONS,\n      variables: {\n        allPairs: allPairsFormatted,\n      },\n      fetchPolicy: 'cache-first',\n    })\n    transactions.mints = result.data.mints\n    transactions.burns = result.data.burns\n    transactions.swaps = result.data.swaps\n  } catch (e) {\n    console.log(e)\n  }\n  return transactions\n}\n\nconst getTokenPairs = async (tokenAddress) => {\n  try {\n    // fetch all current and historical data\n    let result = await client.query({\n      query: TOKEN_DATA(tokenAddress),\n      fetchPolicy: 'cache-first',\n    })\n    return result.data?.['pairs0'].concat(result.data?.['pairs1'])\n  } catch (e) {\n    console.log(e)\n  }\n}\n\nconst getIntervalTokenData = async (tokenAddress, startTime, interval = 3600, latestBlock) => {\n  const utcEndTime = dayjs.utc()\n  let time = startTime\n\n  // create an array of hour start times until we reach current hour\n  // buffer by half hour to catch case where graph isnt synced to latest block\n  const timestamps = []\n  while (time < utcEndTime.unix()) {\n    timestamps.push(time)\n    time += interval\n  }\n\n  // backout if invalid timestamp format\n  if (timestamps.length === 0) {\n    return []\n  }\n\n  // once you have all the timestamps, get the blocks for each timestamp in a bulk query\n  let blocks\n  try {\n    blocks = await getBlocksFromTimestamps(timestamps, 100)\n\n    // catch failing case\n    if (!blocks || blocks.length === 0) {\n      return []\n    }\n\n    if (latestBlock) {\n      blocks = blocks.filter((b) => {\n        return parseFloat(b.number) <= parseFloat(latestBlock)\n      })\n    }\n\n    let result = await splitQuery(PRICES_BY_BLOCK, client, [tokenAddress], blocks, 50)\n\n    // format token ETH price results\n    let values = []\n    for (var row in result) {\n      let timestamp = row.split('t')[1]\n      let derivedETH = parseFloat(result[row]?.derivedETH)\n      if (timestamp) {\n        values.push({\n          timestamp,\n          derivedETH,\n        })\n      }\n    }\n\n    // go through eth usd prices and assign to original values array\n    let index = 0\n    for (var brow in result) {\n      let timestamp = brow.split('b')[1]\n      if (timestamp) {\n        values[index].priceUSD = result[brow].ethPrice * values[index].derivedETH\n        index += 1\n      }\n    }\n\n    let formattedHistory = []\n\n    // for each hour, construct the open and close price\n    for (let i = 0; i < values.length - 1; i++) {\n      formattedHistory.push({\n        timestamp: values[i].timestamp,\n        open: parseFloat(values[i].priceUSD),\n        close: parseFloat(values[i + 1].priceUSD),\n      })\n    }\n\n    return formattedHistory\n  } catch (e) {\n    console.log(e)\n    console.log('error fetching blocks')\n    return []\n  }\n}\n\nconst getTokenChartData = async (tokenAddress) => {\n  let data = []\n  const utcEndTime = dayjs.utc()\n  let utcStartTime = utcEndTime.subtract(1, 'year')\n  let startTime = utcStartTime.startOf('minute').unix() - 1\n\n  try {\n    let allFound = false\n    let skip = 0\n    while (!allFound) {\n      let result = await client.query({\n        query: TOKEN_CHART,\n        variables: {\n          tokenAddr: tokenAddress,\n          skip,\n        },\n        fetchPolicy: 'cache-first',\n      })\n      if (result.data.tokenDayDatas.length < 1000) {\n        allFound = true\n      }\n      skip += 1000\n      data = data.concat(result.data.tokenDayDatas)\n    }\n\n    let dayIndexSet = new Set()\n    let dayIndexArray = []\n    const oneDay = 24 * 60 * 60\n    data.forEach((dayData, i) => {\n      // add the day index to the set of days\n      dayIndexSet.add((data[i].date / oneDay).toFixed(0))\n      dayIndexArray.push(data[i])\n      dayData.dailyVolumeUSD = parseFloat(dayData.dailyVolumeUSD)\n    })\n\n    // fill in empty days\n    let timestamp = data[0] && data[0].date ? data[0].date : startTime\n    let latestLiquidityUSD = data[0] && data[0].totalLiquidityUSD\n    let latestPriceUSD = data[0] && data[0].priceUSD\n    let latestPairDatas = data[0] && data[0].mostLiquidPairs\n    let index = 1\n    while (timestamp < utcEndTime.startOf('minute').unix() - oneDay) {\n      const nextDay = timestamp + oneDay\n      let currentDayIndex = (nextDay / oneDay).toFixed(0)\n      if (!dayIndexSet.has(currentDayIndex)) {\n        data.push({\n          date: nextDay,\n          dayString: nextDay,\n          dailyVolumeUSD: 0,\n          priceUSD: latestPriceUSD,\n          totalLiquidityUSD: latestLiquidityUSD,\n          mostLiquidPairs: latestPairDatas,\n        })\n      } else {\n        latestLiquidityUSD = dayIndexArray[index].totalLiquidityUSD\n        latestPriceUSD = dayIndexArray[index].priceUSD\n        latestPairDatas = dayIndexArray[index].mostLiquidPairs\n        index = index + 1\n      }\n      timestamp = nextDay\n    }\n    data = data.sort((a, b) => (parseInt(a.date) > parseInt(b.date) ? 1 : -1))\n  } catch (e) {\n    console.log(e)\n  }\n  return data\n}\n\nexport function Updater() {\n  const [, { updateTopTokens }] = useTokenDataContext()\n  const [ethPrice, ethPriceOld] = useEthPrice()\n  useEffect(() => {\n    async function getData() {\n      // get top pairs for overview list\n      let topTokens = await getTopTokens(ethPrice, ethPriceOld)\n      topTokens && updateTopTokens(topTokens)\n    }\n    ethPrice && ethPriceOld && getData()\n  }, [ethPrice, ethPriceOld, updateTopTokens])\n  return null\n}\n\nexport function useTokenData(tokenAddress) {\n  const [state, { update }] = useTokenDataContext()\n  const [ethPrice, ethPriceOld] = useEthPrice()\n  const tokenData = state?.[tokenAddress]\n\n  useEffect(() => {\n    if (!tokenData && ethPrice && ethPriceOld && isAddress(tokenAddress)) {\n      getTokenData(tokenAddress, ethPrice, ethPriceOld).then((data) => {\n        update(tokenAddress, data)\n      })\n    }\n  }, [ethPrice, ethPriceOld, tokenAddress, tokenData, update])\n\n  return tokenData || {}\n}\n\nexport function useTokenTransactions(tokenAddress) {\n  const [state, { updateTokenTxns }] = useTokenDataContext()\n  const tokenTxns = state?.[tokenAddress]?.txns\n\n  const allPairsFormatted =\n    state[tokenAddress] &&\n    state[tokenAddress].TOKEN_PAIRS_KEY &&\n    state[tokenAddress].TOKEN_PAIRS_KEY.map((pair) => {\n      return pair.id\n    })\n\n  useEffect(() => {\n    async function checkForTxns() {\n      if (!tokenTxns && allPairsFormatted) {\n        let transactions = await getTokenTransactions(allPairsFormatted)\n        updateTokenTxns(tokenAddress, transactions)\n      }\n    }\n    checkForTxns()\n  }, [tokenTxns, tokenAddress, updateTokenTxns, allPairsFormatted])\n\n  return tokenTxns || []\n}\n\nexport function useTokenPairs(tokenAddress) {\n  const [state, { updateAllPairs }] = useTokenDataContext()\n  const tokenPairs = state?.[tokenAddress]?.[TOKEN_PAIRS_KEY]\n\n  useEffect(() => {\n    async function fetchData() {\n      let allPairs = await getTokenPairs(tokenAddress)\n      updateAllPairs(tokenAddress, allPairs)\n    }\n    if (!tokenPairs && isAddress(tokenAddress)) {\n      fetchData()\n    }\n  }, [tokenAddress, tokenPairs, updateAllPairs])\n\n  return tokenPairs || []\n}\n\nexport function useTokenChartData(tokenAddress) {\n  const [state, { updateChartData }] = useTokenDataContext()\n  const chartData = state?.[tokenAddress]?.chartData\n  useEffect(() => {\n    async function checkForChartData() {\n      if (!chartData) {\n        let data = await getTokenChartData(tokenAddress)\n        updateChartData(tokenAddress, data)\n      }\n    }\n    checkForChartData()\n  }, [chartData, tokenAddress, updateChartData])\n  return chartData\n}\n\n/**\n * get candlestick data for a token - saves in context based on the window and the\n * interval size\n * @param {*} tokenAddress\n * @param {*} timeWindow // a preset time window from constant - how far back to look\n * @param {*} interval  // the chunk size in seconds - default is 1 hour of 3600s\n */\nexport function useTokenPriceData(tokenAddress, timeWindow, interval = 3600) {\n  const [state, { updatePriceData }] = useTokenDataContext()\n  const chartData = state?.[tokenAddress]?.[timeWindow]?.[interval]\n  const [latestBlock] = useLatestBlocks()\n\n  useEffect(() => {\n    const currentTime = dayjs.utc()\n    const windowSize = timeWindow === timeframeOptions.MONTH ? 'month' : 'week'\n    const startTime =\n      timeWindow === timeframeOptions.ALL_TIME ? 1589760000 : currentTime.subtract(1, windowSize).startOf('hour').unix()\n\n    async function fetch() {\n      let data = await getIntervalTokenData(tokenAddress, startTime, interval, latestBlock)\n      updatePriceData(tokenAddress, data, timeWindow, interval)\n    }\n    if (!chartData) {\n      fetch()\n    }\n  }, [chartData, interval, timeWindow, tokenAddress, updatePriceData, latestBlock])\n\n  return chartData\n}\n\nexport function useAllTokenData() {\n  const [state] = useTokenDataContext()\n  return state\n}\n"]},"metadata":{},"sourceType":"module"}